\documentclass{wg21}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{minted}
\usepackage{enumitem}

\lstdefinestyle{base}{
  language=c++,
  breaklines=false,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{green!50!black}]{@}{@},
  escapeinside={(*@}{@*)}
}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}


\title{Reconsidering literal operator templates for strings}
\docnumber{D0424R1}
\audience{Evolution Working Group}
\author{Louis Dionne}{ldionne.2@gmail.com}
\authortwo{Hanicka Dus\'{i}kov\'{a}}{hanicka@hanicka.net}

\begin{document}
\maketitle


\section{Revision history}
\begin{itemize}
  \item R0 -- Initial draft
  \item R1 -- Rewrite with different UDL form per EWG direction, and update motivation
\end{itemize}


\section{Introduction}
C++11 added the ability for users to define their own literals suffixes.
Several forms of literal operators are available, but none of them allows
getting a string literal as a compile-time entity from within the user-defined
literal operator. This prevents the user-defined literal to create an object
whose type depends on the \emph{contents} of the string literal. This paper
proposes solving that problem by allowing user-defined literal operators of
the following form to be considered for string literals:

\begin{cpp}
template <typename CharT, CharT const* str, std::size_t length>
auto operator"" _udl();

auto x = "abcd"_udl; // calls the above function
\end{cpp}


\section{History}
\begin{enumerate}
  \item \cite{N3599} (in 2013) proposed adding the missing literal operator
        using a \cc{char...} parameter pack, but the paper was rejected at
        that time with the following conclusion (\cite{CWG66}):
        \begin{quote}
          Revise with additional machinery for compile time string processing
        \end{quote}
  \item \cite{P0424R0} (the initial revision of this paper) was presented in
        Issaquah in 2016 and argued for adding the missing literal operator
        using a \cc{char...} parameter pack, but the paper was rejected
        because implementers were concerned with the compile-time cost of
        instantiating a function template with such a parameter pack.
  \item This paper addresses implementer's concerns by using a \cc{char const*}
        template parameter instead of a \cc{char...} parameter pack.
\end{enumerate}


\section{Motivation}
Many use cases have recently come up, the most notable ones being compile-time
JSON parsing and compile-time regular expression parsing. For example, a
regular expression engine can be generated at compile-time as follows:

\begin{cpp}
#include "pregexp.hpp"
using namespace sre;

auto regexp = "^(?:[abc]|xyz).+$"_pre;

int main(int argc, char** argv) {
  if (regexp.match(argv[1])) {
    std::cout << "match!" << std::endl;
    return EXIT_SUCCESS;
  } else {
    std::cout << "no match!" << std::endl;
    return EXIT_FAILURE;
  }
}
\end{cpp}

Under the hood, constexpr functions are used to parse the string literal and
generate a type like the following from the string literal:

\begin{cpp}
RegExp<
  Begin,
  Select<Char<'a','b','c'>, String<'x','y','z'>>,
  Plus<Anything>,
  End
>
\end{cpp}

Since the regular expression parser is generated at compile-time, it can be
better optimized and the resulting code is much faster than \cc{std::regex}
(3000x faster has been witnessed).

Similar functionality has traditionally been achieved by using expression
templates and template metaprogramming to build the representation of the
regular expression instead of simply parsing the string at compile-time.
For example, the same regular expression with \cite{Boost.Xpressive} looks
like this:

\begin{cpp}
auto regexp = bos >> ((set='a','b','c')|(as_xpr('x') >> 'y' >> 'z')) >> +_ >> eos;
\end{cpp}

It is worth noting that the specific use case of parsing regular expressions
at compile-time came up at CppCon during a lightning talk, and the room showed
a very strong interest in getting a standardized solution to this problem.
Today, we must rely on a non-standard extension provided by Clang and GCC.


\section{How would that work?}
The idea behind how this operator would work is that the compiler would
generate a constexpr string and pass that to the user-defined literal.
For example:

\begin{cpp}
template <typename CharT, CharT const* str, std::size_t length>
auto operator"" _udl();

"foobar"_udl;

// should be roughly equivalent to

constexpr char __unnamed[] = "foobar";
operator""_udl<char, __unnamed, sizeof(__unnamed)-1>();
\end{cpp}

Calling a function template with such a template-parameter-list works in
\href{https://wandbox.org/permlink/RBV6abYfNee94wlW}{Clang} and
\href{https://wandbox.org/permlink/rZEY8vDB5mHMPmmd}{GCC} today.


\section{Implementation experience}
A very similar literal operator is already provided by both Clang and GCC:

\begin{cpp}
  template <typename CharT, CharT ...s>
  constexpr auto operator"" _udl(); // works
\end{cpp}

It is expected that implementing support for the proposed user-defined literal
operator should be easy.


\section{Wording}
Wording will be provided if the proposal makes it through EWG.


\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

  \bibitem[N3599]{N3599}
    Richard Smith,
    \emph{Literal operator templates for strings}\newline
    \url{http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html}

  \bibitem[P0424R0]{P0424R0}
    Louis Dionne,
    \emph{Reconsidering literal operator templates for strings}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf}

  \bibitem[CWG66]{CWG66}
    Richard Smith,
    \emph{EWG Issue \#66}\newline
    \url{http://cplusplus.github.io/EWG/ewg-active.html#66}

  \bibitem[Boost.Xpressive]{Boost.Xpressive}
    Eric Niebler,
    \emph{Boost.Xpressive}\newline
    \url{http://www.boost.org/doc/libs/release/doc/html/xpressive.html}

\end{thebibliography}

\end{document}
