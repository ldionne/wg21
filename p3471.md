---
title: "Standard library hardening"
document: D3471R4
date: 2024-12-14
audience: LWG, CWG
author:
  - name: Konstantin Varlamov
    email: <varconst@apple.com>
  - name: Louis Dionne
    email: <ldionne@apple.com>
toc: false
toc-depth: 4
---

# Introduction

This paper proposes introducing _standard library hardening_ into the C++ Standard. Hardening allows turning some instances of undefined behavior in the standard library into a contract violation. This proposal is based on our experience implementing [hardening in libc++](https://libcxx.llvm.org/Hardening.html) and deploying it widely.

# Revision history

- R4 (LWG in Hagenberg): ...
- R3 (seen by LEWG in Hagenberg): Added the specialization of `expected` for `void` types to the wording.
- R2: Added full wording and an FAQ section.
- R1: Revision rebased on top of contract violations.
- R0: Initial proposal based on "terminating in an implementation-defined way".

# Motivation

There has been significantly increased attention to safety and security in C++ over the last few years, as exemplified by the well-known [White House report](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf) and numerous recent security-related proposals.

While it is important to explore ways to make _new_ code safer, we believe that the highest priority to deliver immediate real-world value should be to make _existing_ code safer with minimal or no effort on behalf of users. Indeed, the amount of existing security-critical C++ code is so large that rewriting it or modifying it is both economically unviable and dangerous given the risk of introducing new issues.

There have been a few proposals accepted recently that eliminate some cases of undefined behavior in the core language. The standard library also contains many instances of undefined behavior, some of which is a direct source of security vulnerabilities; addressing those is often trivial, can be done with low overhead and almost no work on behalf of users.

In fact, at the moment all three major library implementations have some notion of a hardened or debug mode. This clearly shows interest, both from users and from implementers, in having a safer mode for the standard library. However, we believe these efforts would be vastly more useful if they were standardized and provided portable, cross-platform guarantees to users; as it stands, implementations differ in levels of coverage, performance guarantees and ways to enable the safer mode.

Finally, leaving security of the library to be a pure vendor extension fails to position ISO C++ as providing a credible solution for code bases with formal security requirements. We believe that formally requiring the basic safety guarantees that most implementations already provide in one way or another could make a significant difference from the point of view of anyone writing or following safety and security coding standards and guidelines.

# Deployment experience

All three major implementations provide vendor-specific ways of enabling library assertions as proposed in this paper, today.

- We have experience deploying hardening on Apple platforms in several existing codebases.
- Google recently published [an article](https://security.googleblog.com/2024/11/retrofitting-spatial-safety-to-hundreds.html) where they describe their experience with deploying this very technology to hundreds of millions of lines of code. They reported a performance impact as low as 0.3% and finding over 1000 bugs, including security-critical ones.
- Google Andromeda published [an article](https://bughunters.google.com/blog/6368559657254912/llvm-s-rfc-c-buffer-hardening-at-google) ~1 year ago about their successful experience enabling hardening.
- The libc++ maintainers have received numerous informal reports of hardening being turned on and helping find bugs in codebases.

Overall, standard library hardening has been a huge success, in fact we never expected so much success. The reception has been overwhelmingly positive and while the quality of implementation will never be perfect, we are working hard to expand the scope of hardening in libc++, to improve its performance and the user experience.

# Design overview

At a high level, this proposal consists of two parts:

* Annotate _some_ existing library preconditions as _hardened_.
* Define the notion of a _hardened implementation_. In a hardened implementation, _hardened preconditions_ are checked at runtime and violating them is a contract violation.

There are a few important aspects to the proposed design:

* In a _hardened implementation_, it is not possible to "turn off" these precondition checks by using the `ignore` semantic. Since we specify that violating a _hardened precondition_ is a contract violation, we are already past the point where `ignore` could bypass the check.
* We only propose to formally check (some of the) existing function preconditions, not to add any new preconditions. As a drive-by, we also make a few existing preconditions more explicit in the specification (e.g. `vector::operator[]` only has implicit preconditions via iterator validity).
* Hardening deals exclusively with preconditions that must be checked at runtime. Thus, performance overhead is an important constraint.
* Hardening is intended to avoid requiring changes to an implementation's ABI. In particular, the intent is to make it possible for implementations to allow mixing hardened and unhardened code in the same program, if they wish to do so.
* Hardening needs to be lightweight enough to be used in production environments. In our experience, a debug-only approach is not sufficient to really move the needle security-wise. Thus, the goal is to identify the minimal set of checks that would deliver the most value to users while requiring minimal overhead, with a particular focus on memory safety as a major source of security vulnerabilities. Checking _all_ preconditions in the library is an explicit non-goal, and would be impossible for many semantic requirements anyway.

To reiterate the last point, an important design principle is that hardening needs to be lightweight enough for production use by a wide variety of real-world programs. In our experience in libc++, a small set of checks that is widely used delivers far more value than a more extensive set of checks that is only enabled by select few users. Thankfully, many of the most valuable checks, such as checking for out-of-bounds access in standard containers, also happen to be relatively cheap.

# Hardened preconditions

To specify hardening in the Standard, this proposal introduces the notion of a _hardened precondition_. A _hardened precondition_ is a precondition that results in a contract violation in a _hardened implementation_. Adding hardening to the library largely consists of turning some of the existing preconditions into _hardened preconditions_ in the specification. For example:

[23.7.2.2.6]{.pnum} **Element access**     `[span.elem]`

```cpp
constexpr reference operator[](size_type idx) const;
```
[1]{.pnum} [Hardened]{.add} [P]{.rm}[p]{.add}reconditions: `idx < size()` is `true`.

In the initial proposal, we decide to focus on hardened preconditions that prevent out-of-bounds memory access, i.e., compromise the memory safety of the program. These are some of the most valuable for the user since they help prevent potential security vulnerabilities; many of them are also relatively cheap to implement. More hardened preconditions can potentially be added in the future, but the intent is for their number to be limited to keep hardening viable for production use. Specifically, the proposal is to add hardened preconditions to:

* Accessors of sequence containers, `std::span`, `std::mdspan`, `std::string`, `std::string_view` and other similar classes that might attempt to access non-existent elements (e.g. `back()` on an empty container or `operator[]` with an invalid index).
* Modifiers of sequence containers and string classes that assume the container to be non-empty (e.g. `pop_back()`).
* Accessors of `optional` and `expected` that expect the object to be non-empty.

In our experience, hardening all of these operations is trivial to implement and provides significant security value.

# Enabling hardening

Much like a freestanding implementation, the way to request a _hardened_ implementation is left for the implementation to define. For example, similarly to `-ffreestanding`, we expect that most toolchains would provide a compiler flag like `-fhardened`, but other alternatives like a `-D_LIBCPP_HARDENING_MODE=<mode>` macro would also be conforming. If this proposal gets accepted, we expect implementations to converge on a portable mechanism. Other details like whether hardened implementations and non-hardened implementations can be mixed in different translation units are intentionally left unspecified, to avoid overconstraining the implementations.

# Relationship to Contracts, Profiles, and Erroneous Behavior

## Contracts

Contracts is a new (in-progress) language feature that allows expressing preconditions and much more, with a lot of flexibility on what happens when an assertion is not satisfied. In the latest revision of this paper, we decided to base _hardened preconditions_ on contract violations for several reasons:

- It provides a unifying framework for specifying what should be done when "something goes wrong" both at the language and the library level. A unified mechanism is something that our current hardening clients have been repeatedly requesting.
- It provides flexibility for handling contract violations in a way that best suits the user. In particular, our deployment experience has made it clear that different users have different requirements, and that e.g. the weaker `observe` semantics can be extremely useful to allow deploying this at scale.

It is useful to note that we don't require implementations to actually implement these checks as contract assertions. Implementations are free to implement precondition checking however they see fit (e.g. a macro), however they are required to employ the contract violation handling mechanism when a precondition is not satisfied.

Note that if Contracts were to not be pursued anymore, this feature could easily be reworded in terms of a guaranteed termination in an implementation-defined way, or using Erroneous Behavior. We are not strongly attached to the exact mechanism used to implement this, but we find that Contracts is a nearly perfect fit.

## Profiles

The various Profiles proposals introduce a framework to specify sets of safety guarantees (such as a type safety profile or an invalidation profile). If profiles become a part of the Standard in the future, hardening can most likely be formulated as an additional profile; this would formalize how hardening is turned on and off.

However, we feel strongly that a hardening mode as specified in this paper standardizes existing practice and delivers value today without waiting for a larger and still experimental language feature.

## Erroneous Behavior

While Erroneous Behavior is a way to clearly mark some code as incorrect in the specification, it does not clearly specify *what* should happen in case of EB. For example, a conforming behavior for `vector::operator[]` being called out-of-bounds under EB would be to return the last element of the vector instead. While that is well-defined behavior, we feel that it is not especially useful behavior and that is certainly not what our users are looking for. In contrast, the Contracts facilities provide a well-defined and flexible framework to handle this.

<!---
# Summary of proposed changes

Functions with preconditions that will be hardened are listed in the tables
below. A dash `-` indicates that the class does not have the corresponding
member function.

> \centering{}
| Class / Function    | `operator[]` | `front()` | `back()`  | `pop_front()` | `pop_back()` |
| :--------------:    | :----------: | :-------: | :------:  | :-----------: | :----------: |
| `array`             | ✅           | ✅        | ✅        | -             | -            |
| `basic_string`      | ✅           | ✅        | ✅        | -             | ✅           |
| `deque`             | ✅           | ✅        | ✅        | ✅            | ✅           |
| `forward_list`      | -            | ✅        | -         | ✅            | -            |
| `inplace_vector`    | ✅           | ✅        | ✅        | -             | ✅           |
| `list`              | -            | ✅        | ✅        | ✅            | ✅           |
| `vector`            | ✅           | ✅        | ✅        | -             | ✅           |
| `span`              | ✅           | ✅        | ✅        | -             | -            |
| `basic_string_view` | ✅           | ✅        | ✅        | -             | -            |
| `mdspan`            | ✅           | -         | -         | -             | -            |
| `bitset`            | ✅           | -         | -         | -             | -            |
| `valarray`          | ✅           | -         | -         | -             | -            |

| Class / Function | `operator->` | `operator*` | `error`  |
| :--------------: | :----------: | :-------:   | :------: |
| `optional`       | ✅           | ✅          | -        |
| `expected`       | ✅           | ✅          | ✅       |

In addition to the tables above, hardened preconditions are added to the following functions:

- `span::first` (all overloads);
- `span::last` (all overloads);
- `span::subspan` (all overloads);
- `basic_string_view::remove_prefix`;
- `basic_string_view::remove_suffix`;
- `span` constructors that take a range (including another `span`) of which the size is not statically known;
- the `mdspan` constructor taking another `mdspan` with different template arguments.

-->

# FAQ

## Notable omissions

### `erase` member functions

Most containers have an `erase` member function that takes an iterator into the container and erases the element it points to. These functions have an implicit precondition that comes from the fact that the iterator argument is defined to denote "a valid dereferenceable constant iterator to [the container]".

Unfortunately, this precondition can only be checked for some containers and not others. For a contiguous container, the iterator can be lowered to a pointer; the pointer can then be tested to check whether it points within the bounds of the container's underlying storage (using `std::less` and the related function object classes). There is, however, no feasible way to do a similar check for a non-contiguous container (without requiring an ABI break and significant overhead). In this paper, we would prefer to focus on preconditions that can be checked in a clear and straightforward way across all applicable classes; less obvious cases would be better served by a separate dedicated paper.

### Associative containers

Most preconditions of associative containers do not map clearly to spatial safety; moreover, associative containers have a significantly different interface and implementation compared to the containers covered by this paper. Since specifying preconditions that are relevant for memory safety in the associative containers is less straightforward than for sequence containers and since we don't have sufficient implementation experience hardening those, we prefer to explore hardening for associative containers in a dedicated paper.

### Algorithms

All algorithms (in fact, all library functions) that operate on ranges have an implicit precondition that the ranges are valid. Unfortunately, that precondition can only be checked partially and for contiguous iterators, where it is trivial to check that the end of the range is reachable from the beginning. In the general case, it is also impossible to check that both iterators point into the same container, which doesn't appear to be covered by the "valid range" requirement but is required in practice for these algorithms to do something sensible. Moreover, since "valid range" is a blanket requirement effectively covering all library functions, we have limited implementation experience with hardening algorithms, our current approach having focused on containers and container-like classes so far.

Some algorithms taking one range as an input and another as an output have a precondition that the two ranges do not overlap. This precondition also cannot be checked in the general case (for example, the iterators might be input iterators, meaning they cannot be "rewinded" after being incremented which would be required to perform a check).

For all of these reasons, we decided to leave hardening of the algorithms to a dedicated paper.

### `mdspan` extents and layout classes

Classes representing the extents and the layout mapping of an `mdspan` (`extents`, `layout_left`, `layout_right`, `layout_stride`) contain several preconditions that can be considered for hardening. However, these are large, complicated classes with non-trivial interactions with the `mdspan` class itself; it would require dedicated effort and research to make sure all relevant cases are hardened and there is no redundancy leading to unnecessary overhead. As such, we would prefer to keep the initial proposal focused on preconditions that are trivial to check and reason about and defer `mdspan` to a separate paper.

### `valarray`

Similarly to `mdspan`, `valarray` is non-trivial to harden properly. Its API is effectively spread across several helper classes that interact in non-trivial ways. After surverying our implementation, we believe that our implementation experience with `valarray` hardening is not sufficient at this time to include more than basic hardening of `operator[]` in this paper. We would prefer to leave a thorough exploration of `valarray` to a dedicated paper.

## Specifying previously implicit preconditions for sequence containers

Before this proposal, several member functions of sequence containers (specifically, `front`, `back` and `operator[]`) do not have an explicit precondition. Rather, their preconditions are formulated implicitly via a _Returns_ or an _Effects_ element of the function description (for example, "_Returns_: `*a.begin()`" implies that `a.begin()` returns a dereferenceable iterator). It might seem that the most natural way to express the precondition would be to assume the container is not empty (as is the case for some other functions defined in the same section, such as `pop_back`):

> `a.front()`
>
> [69]{.pnum} _Result_: `reference`; `const_reference` for constant `a`.
>
::: add
> [70]{.pnum} _Hardened preconditions_: `!a.empty()`.
:::
> [71]{.pnum} _Returns_: `*a.begin()`

However, this formulation would be subtly different from the existing implicit precondition. Consider an implementation that defines, let's say, a deque iterator type such that the singular iterator returned by `a.end()` is dereferenceable and returns a reference to some sentinel value (perhaps as an attempt to be "user-friendly"). There doesn't seem to be anything in the current text of the Standard that rules out such an implementation; thus, under the current specification, calling `a.front()` on an empty `deque` would be perfectly well-defined when using that implementation. However, if we were to formulate the precondition to assume that the container is not empty, that would make this previously-valid code run into undefined behavior in a non-hardened implementation (and terminate in a hardened implementation).

For this reason, we try to stay as close as possible to the existing specification and formulate the precondition in terms of iterator validity:

> `a.front()`
>
> [69]{.pnum} _Result_: `reference`; `const_reference` for constant `a`.
>
::: add
> [70]{.pnum} _Hardened preconditions_: `a.begin()` is dereferenceable.
:::
> [71]{.pnum} _Returns_: `*a.begin()`

While expressing a precondition this way might make it seem complicated, in practice an implementation would know exactly when the iterator is dereferenceable, making this check easy to implement (most implementations can simply check that the container is not empty).

# Proposed wording

## Introduce hardened preconditions

<!-- Change in 7.5.4.1 [expr.prim.id.unqual] paragraph 2: -->
Add a new paragraph to [intro.compliance]{.sref} after paragraph 7 as indicated:

> [7]{.pnum} Two kinds of implementations are defined: a _hosted implementation_ and a _freestanding implementation._ A freestanding implementation is one in which execution may take place without the benefit of an operating system. A hosted implementation supports all the facilities described in this document, while a freestanding implementation supports the entire C++ language described in `[lex]` through `[cpp]` and the subset of the library facilities described in `[compliance]`.

:::add
> [8]{.pnum} Additionally, an implementation can be a _hardened implementation_. A hardened implementation is one in which violating a _hardened precondition_ is a contract violation.
:::

Add a new element to [structure.specifications]{.sref} after element 3.3 as indicated:

> [3.3]{.pnum} _Preconditions_: the conditions that the function assumes to hold whenever it is called; violation of any preconditions results in undefined behavior.

:::add
> [3.4]{.pnum} _Hardened preconditions_: the conditions that the function assumes to hold whenever it is called; violation of any hardened preconditions results in a contract violation in a hardened implementation, and undefined behavior otherwise.
:::

## `span`

### `span::operator[]`

Modify [span.elem]{.sref} paragraph 1 as indicated:

> `constexpr reference operator[](size_type idx) const;`
>
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `idx < size()` is `true`.
>
> [2]{.pnum} _Returns_: `*(data() + idx)`.
>
> [3]{.pnum} _Throws_: Nothing.

### `span::front`

Modify [span.elem]{.sref} paragraph 6 as indicated:

> `constexpr reference front() const;`
>
> [6]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [7]{.pnum} _Returns_: `*data()`.
>
> [8]{.pnum} _Throws_: Nothing.

### `span::back`

Modify [span.elem]{.sref} paragraph 9 as indicated:

> `constexpr reference back() const;`
>
> [9]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [10]{.pnum} _Returns_: `*(data() + (size() - 1))`.
>
> [11]{.pnum} _Throws_: Nothing.

### `span::first`

Modify [span.sub]{.sref} paragraph 2 as indicated:

> `template<size_t Count> constexpr span<element_type, Count> first() const;`
>
> [1]{.pnum} _Mandates_: `Count <= Extent` is `true`.
>
> [2]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `Count <= size()` is `true`.
>
> [3]{.pnum} _Effects_: Equivalent to: `return R{data(), Count};` where `R` is the return type.

Modify [span.sub]{.sref} paragraph 11 as indicated:

> `constexpr span<element_type, dynamic_extent> first(size_type count) const;`
>
> [11]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `count <= size()` is `true`.
>
> [12]{.pnum} _Effects_: Equivalent to: `return {data(), count};`

### `span::last`

Modify [span.sub]{.sref} paragraph 5 as indicated:

> `template<size_t Count> constexpr span<element_type, Count> last() const;`
>
> [4]{.pnum} _Mandates_: `Count <= Extent` is `true`.
>
> [5]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `Count <= size()` is `true`.
>
> [6]{.pnum} _Effects_: Equivalent to: `return R{data() + (size() - Count), Count};` where `R` is the return type.

Modify [span.sub]{.sref} paragraph 13 as indicated:

> `constexpr span<element_type, dynamic_extent> last(size_type count) const;`
>
> [13]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `count <= size()` is `true`.
>
> [14]{.pnum} _Effects_: Equivalent to: `return {data() + (size() - count), count};`

### `span::subspan`

Modify [span.sub]{.sref} paragraph 8 as indicated:

> ```
> template<size_t Offset, size_t Count = dynamic_extent>
>   constexpr span<element_type, @_see below_@> subspan() const;
> ```
>
> [7]{.pnum} _Mandates_:
> ```
>   Offset <= Extent && (Count == dynamic_extent || Count <= Extent - Offset)
> ```
> is `true`.
>
> [8]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_:
> ```
>   Offset <= size() && (Count == dynamic_extent || Count <= size() - Offset)
> ```
> is `true`.

Modify [span.sub]{.sref} paragraph 15 as indicated:

> ```
> constexpr span<element_type, dynamic_extent> subspan(
>   size_type offset, size_type count = dynamic_extent) const;
> ```
>
> [15]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_:
> ```
>   offset <= size() && (count == dynamic_extent || count <= size() - offset)
> ```
> is `true`.

### `span` constructors

Modify [span.cons]{.sref} around paragraph 4 as indicated:

> ```
> template<class It>
>   constexpr explicit(extent != dynamic_extent) span(It first, size_type count);
> ```
> [...]
>
> [4]{.pnum} _Preconditions_:
>
> [4.1]{.pnum} - `[first, first + count)` is a valid range.
>
> [4.2]{.pnum} - `It` models `contiguous_iterator`.
>
:::rm
> [4.3]{.pnum} - If `extent` is not equal to `dynamic_extent`, then `count` is equal to `extent`.
:::
>
:::add
> [5]{.pnum} _Hardened preconditions_: If `extent` is not equal to `dynamic_extent`, then `count == extent` is `true`.
:::
>
> [?]{.pnum} _Effects_: Initializes `data_` with `to_address(first)` and `size_` with `count`.
>
> [?]{.pnum} _Throws_: Nothing.

Modify [span.cons]{.sref} around paragraph 8 as indicated:

> ```
> template<class It, class End>
>   constexpr explicit(extent != dynamic_extent) span(It first, End last);
> ```
> [...]
>
> [8]{.pnum} _Preconditions_:
>
:::rm
> [8.1]{.pnum} - If `extent` is not equal to `dynamic_extent`, then `last - first` is equal to `extent`.
:::
>
> [8.?]{.pnum} - `[first, last)` is a valid range.
>
> [8.?]{.pnum} - `It` models `contiguous_iterator`.
>
> [8.?]{.pnum} - `End` models `sized_sentinel_for<It>`.
>
:::add
> [9]{.pnum} _Hardened preconditions_: If `extent` is not equal to `dynamic_extent`, then `(last - first) == extent` is `true`.
:::
>
> [?]{.pnum} _Effects_: Initializes `data_` with `to_address(first)` and `size_` with `last - first`.
>
> [?]{.pnum} _Throws_: When and what `last - first` throws.

Modify [span.cons]{.sref} around paragraph 15 as indicated:

> ```
> template<class R> constexpr explicit(extent != dynamic_extent) span(R&& r);
> ```
> [...]
>
> [15]{.pnum} _Preconditions_:
>
:::rm
> [15.1]{.pnum} - If `extent` is not equal to `dynamic_extent`, then `ranges::size(r)` is equal to `extent`.
:::
>
> [15.?]{.pnum} - `R` models `ranges::contiguous_range` and `ranges::sized_range`.
>
> [15.?]{.pnum} - If `is_const_v<element_type>` is `false`, `R` models `ranges::borrowed_range`.
>
:::add
> [16]{.pnum} _Hardened preconditions_: If `extent` is not equal to `dynamic_extent`, then `ranges::size(r) == extent` is `true`.
:::
> [?]{.pnum} _Effects_: Initializes data_ with `ranges::data(r)` and `size_` with `ranges::size(r)`.
>
> [?]{.pnum} _Throws_: What and when `ranges::data(r)` and `ranges::size(r)` throw.

Modify [span.cons]{.sref} paragraph 19 as indicated:

> ```
> constexpr explicit(extent != dynamic_extent) span(std::initializer_list<value_type> il);
> ```
> [18]{.pnum} _Constraints_: `is_const_v<element_type>` is `true`.
>
> [19]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: If `extent` is not equal to `dynamic_extent`, then [`il.size()` is equal to `extent`]{.rm}[`il.size() == extent` is `true`]{.add}.
>
> [20]{.pnum} _Effects_: Initializes `data_` with `il.begin()` and `size_` with `il`.size().

Modify [span.cons]{.sref} paragraph 23 as indicated:

> ```
> template<class OtherElementType, size_t OtherExtent>
>   constexpr explicit(see below) span(const span<OtherElementType, OtherExtent>& s) noexcept;
> ```
> [22]{.pnum} _Constraints_:
>
> [22.1]{.pnum} - `extent == dynamic_extent || OtherExtent == dynamic_extent || extent == OtherExtent` is `true`, and
>
> [22.2]{.pnum} - `is_convertible_v<OtherElementType(*)[], element_type(*)[]>` is `true`.
>
> [_Note 6_: The intent is to allow only qualification conversions of the `OtherElementType` to `element_type`. — _end note_]
>
> [23]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: If `extent` is not equal to `dynamic_extent`, then [`s.size()` is equal to `extent`]{.rm}[`s.size() == extent` is `true`]{.add}.
>
> [24]{.pnum} _Effects_: Constructs a `span` that is a view over the range `[s.data(), s.data() + s.size())`.

## `basic_string_view`

### `basic_string_view::operator[]`

Modify [string.view.access]{.sref} paragraph 1 as indicated:

> `constexpr const_reference operator[](size_type pos) const;`
>
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `pos < size()` [is `true`]{.add}.
>
> [[4]{.pnum} [_Note 1_: This precondition is stronger than the one on `basic_string::operator[]`. — `end note`]]{.add}
>
> [2]{.pnum} _Returns_: `data_[pos]`.
>
> [3]{.pnum} _Throws_: Nothing.
>
> [[4]{.pnum} [_Note 1_: Unlike `basic_string::operator[]`, `basic_string_view::operator[](size())` has undefined behavior instead of returning `charT()`. — `end note`]]{.rm}

### `basic_string_view::front`

Modify [string.view.access]{.sref} paragraph 7 as indicated:

> `constexpr const_reference front() const;`
>
> [7]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [8]{.pnum} _Returns_: `data_[0]`.
>
> [9]{.pnum} _Throws_: Nothing.

### `basic_string_view::back`

Modify [string.view.access]{.sref} paragraph 10 as indicated:

> `constexpr const_reference back() const;`
>
> [10]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [11]{.pnum} _Returns_: `data_[size() - 1]`.
>
> [12]{.pnum} _Throws_: Nothing.

### `basic_string_view::remove_prefix`

Modify [string.view.modifiers]{.sref} paragraph 1 as indicated:

> `constexpr void remove_prefix(size_type n);`
>
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `n <= size()` is `true`.
>
> [2]{.pnum} _Effects_: Equivalent to: `data_ += n; size_ -= n;`

### `basic_string_view::remove_suffix`

Modify [string.view.modifiers]{.sref} paragraph 3 as indicated:

> `constexpr void remove_suffix(size_type n);`
>
> [3]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `n <= size()` is `true`.
>
> [4]{.pnum} _Effects_: Equivalent to: `size_ -= n;`

## Sequence containers

### `a.front()`

Modify [sequence.reqmts]{.sref} around paragraph 69 as indicated:

> `a.front()`
>
> [69]{.pnum} _Result_: `reference`; `const_reference` for constant `a`.
>
::: add
> [70]{.pnum} _Hardened preconditions_: `a.empty()` is `false`.
:::
> [71]{.pnum} _Returns_: `*a.begin()`
>
> [72]{.pnum} _Remarks_: Required for `basic_string`, `array`, `deque`, `forward_list`, `inplace_vector`, `list`, and `vector`.
>

### `a.back()`

Modify [sequence.reqmts]{.sref} around paragraph 72 as indicated:

> `a.back()`
>
> [72]{.pnum} _Result_: `reference`; `const_reference` for constant `a`.
>
::: add
> [73]{.pnum} _Hardened preconditions_: `a.empty()` is `false`.
>
:::
> [74]{.pnum} _Effects_: Equivalent to:
>
>  ```
>   auto tmp = a.end();
>   --tmp;
>   return *tmp;
>  ```
>
> [75]{.pnum} _Remarks_: Required for `basic_string`, `array`, `deque`, `inplace_vector`, `list`, and `vector`.
>

### `a.pop_front()`

Modify [sequence.reqmts]{.sref} paragraph 110 as indicated:

> `a.pop_front()`
>
> [109]{.pnum} _Result_: `void`
>
> [110]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `a.empty()` is `false`.
>
> [111]{.pnum} _Effects_: Destroys the first element.
>
> [112]{.pnum} _Remarks_: Required for `deque`, `forward_list`, and `list`.

### `a.pop_back()`

Modify [sequence.reqmts]{.sref} paragraph 114 as indicated:

> `a.pop_back()`
>
> [113]{.pnum} _Result_: `void`
>
> [114]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `a.empty()` is `false`.
>
> [115]{.pnum} _Effects_: Destroys the last element.
>
> [116]{.pnum} _Remarks_: Required for `basic_string`, `deque`, `inplace_vector`, `list`, and `vector`.

### `a[n]`

Modify [sequence.reqmts]{.sref} around paragraph 117 as indicated:

> `a[n]`
>
> [117]{.pnum} _Result_: `reference`; `const_reference` for constant `a`
>
::: add
> [118]{.pnum} _Hardened preconditions_: `n < a.size()` is `true`.
:::
> [119]{.pnum} _Effects_: Equivalent to: `return *(a.begin() + n);`
>
> [120]{.pnum} _Remarks_: Required for `basic_string`, `array`, `deque`, `inplace_vector`, and `vector`.

## `basic_string`

### `basic_string::operator[]`

Modify [string.accessors]{.sref} paragraph 1 as indicated:

> ```
> constexpr const_reference operator[](size_type pos) const;
> constexpr reference       operator[](size_type pos);
> ```
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `pos <= size()` is `true`.
>
> [2]{.pnum} _Returns_: `*(begin() + pos)` if `pos < size()`. Otherwise, returns a reference to an object of type `charT` with value `charT()`, where modifying the object to any value other than `charT()` leads to undefined behavior.
>
> [3]{.pnum} _Throws_: Nothing.
>
> [4]{.pnum} _Complexity_: Constant time.

### `basic_string::front`

Modify [string.accessors]{.sref} paragraph 7 as indicated:

> ```
> constexpr const charT& front() const;
> constexpr charT& front();
> ```
> [7]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [8]{.pnum} _Effects_: Equivalent to: `return operator[](0);`

### `basic_string::back`

Modify [string.accessors]{.sref} paragraph 9 as indicated:

> ```
> constexpr const charT& back() const;
> constexpr charT& back();
> ```
> [9]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [10]{.pnum} _Effects_: Equivalent to: `return operator[](size() - 1);`

### `basic_string::pop_back`

Modify [string.erase]{.sref} paragraph 12 as indicated:

> ```
> constexpr void pop_back();
> ```
> [12]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `empty()` is `false`.
>
> [13]{.pnum} _Effects_: Equivalent to `erase(end() - 1)`.
>
> [14]{.pnum} _Throws_: Nothing.

## `mdspan`

### `mdspan::operator[]`

Modify [mdspan.mdspan.members]{.sref} paragraph 3 as indicated:

> ```
> template<class... OtherIndexTypes>
>   constexpr reference operator[](OtherIndexTypes... indices) const;
> ```
> [...]
>
> [2]{.pnum} Let `I` be `extents_type::@_index-cast_@(std::move(indices))`.
>
> [3]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `I` is a multidimensional index in `extents()`.
>
> [_Note 1_: This implies that `map_(I) < map_.required_span_size()` is `true`. — _end note_]

### `mdspan` constructor

Modify [mdspan.mdspan.cons]{.sref} around paragraph 21 as indicated:

> ```
> template<class OtherElementType, class OtherExtents,
>          class OtherLayoutPolicy, class OtherAccessor>
>   constexpr explicit(@_see below_@)
>     mdspan(const mdspan<OtherElementType, OtherExtents,
>                         OtherLayoutPolicy, OtherAccessor>& other);
> ```
> [...]
>
> [21]{.pnum} _Preconditions_:
>
:::rm
> [21.1]{.pnum} - For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.
>
:::
> [21.?]{.pnum} - `[0, map_.required_span_size())` is an accessible range of `ptr_` and `acc_` for values of `ptr_`, `map_`, and `acc_` after the invocation of this constructor.
>
:::add
> [2?]{.pnum} _Hardened preconditions_:
>
> [2?.1]{.pnum} - For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.
>
:::

## `bitset`

### `bitset::operator[]`

Modify [bitset.members]{.sref} paragraph 30 as indicated:

> ```
> constexpr bool operator[](size_t pos) const;
> ```
> [30]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: [`pos` is valid]{.rm}[`pos < size()` is `true`]{.add}.
>
> [31]{.pnum} _Returns_: `true` if the bit at position `pos` in `*this` has the value one, otherwise `false`.
>
> [32]{.pnum} _Throws_: Nothing.

Modify [bitset.members]{.sref} paragraph 33 as indicated:

> ```
> constexpr bitset::reference operator[](size_t pos);
> ```
> [33]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: [`pos` is valid]{.rm}[`pos < size()` is `true`]{.add}.
>
> [34]{.pnum} _Returns_: An object of type `bitset::reference` such that `(*this)[pos] == this->test(pos)`, and such that `(*this)[pos] = val` is equivalent to `this->set(pos, val)`.
>
> [35]{.pnum} _Throws_: Nothing.

## `valarray`

### `valarray::operator[]`

Modify [valarray.access]{.sref} paragraph 1 as indicated:

> ```
> const T&  operator[](size_t n) const;
> T& operator[](size_t n);
> ```
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `n < size()` is `true`.
>
> [2]{.pnum} _Returns_: A reference to the corresponding element of the array.

## `optional`

### `optional::operator->`

Modify [optional.observe]{.sref} paragraph 1 as indicated:

> `constexpr const T* operator->() const noexcept;`
>
> `constexpr T* operator->() noexcept;`
>
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: [`*this` contains a value]{.rm}[`has_value()` is `true`]{.add}.
>
> [2]{.pnum} _Returns_: `*val`.
>
> [3]{.pnum} _Remarks_: These functions are `constexpr` functions.

### `optional::operator*`

Modify [optional.observe]{.sref} paragraph 4 as indicated:

> `constexpr const T& operator*() const & noexcept;`
>
> `constexpr T& operator*() & noexcept;`
>
> [4]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: [`*this` contains a value]{.rm}[`has_value()` is `true`]{.add}.
>
> [5]{.pnum} _Returns_: `*val`.
>
> [6]{.pnum} _Remarks_: These functions are `constexpr` functions.

Modify [optional.observe]{.sref} paragraph 7 as indicated:

> `constexpr T&& operator*() && noexcept;`
>
> `constexpr const T&& operator*() const && noexcept;`
>
> [7]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: [`*this` contains a value]{.rm}[`has_value()` is `true`]{.add}.
>
> [8]{.pnum} _Effects_: Equivalent to: `return std::move(*val);`

## `expected`

### `expected::operator->`

Modify [expected.object.obs]{.sref} paragraph 1 as indicated:

> `constexpr const T* operator->() const noexcept;`
>
> `constexpr T* operator->() noexcept;`
>
> [1]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `true`.
>
> [2]{.pnum} _Returns_: `addressof(val)`.

### `expected::operator*`

Modify [expected.object.obs]{.sref} paragraph 3 as indicated:

> `constexpr const T& operator*() const & noexcept;`
>
> `constexpr T& operator*() & noexcept;`
>
> [3]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `true`.
>
> [4]{.pnum} _Returns_: `val`.

Modify [expected.object.obs]{.sref} paragraph 5 as indicated:

> `constexpr T&& operator*() && noexcept;`
>
> `constexpr const T&& operator*() const && noexcept;`
>
> [5]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `true`.
>
> [6]{.pnum} _Returns_: `std::move(val)`.

Modify [expected.void.obs]{.sref} paragraph 2 as indicated:

> `constexpr void operator*() const noexcept;`
>
> [2]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `true`.

### `expected::error()`

Modify [expected.object.obs]{.sref} paragraph 14 as indicated:

> `constexpr const E& error() const & noexcept;`
>
> `constexpr E& error() & noexcept;`
>
> [14]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `false`.
>
> [15]{.pnum} _Returns_: _`unex`_.

Modify [expected.object.obs]{.sref} paragraph 16 as indicated:

> `constexpr E&& error() && noexcept;`
>
> `constexpr const E&& error() const && noexcept;`
>
> [16]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `false`.
>
> [17]{.pnum} _Returns_: `std::move(`_`unex`_`)`.

Modify [expected.void.obs]{.sref} paragraph 7 as indicated:

> `constexpr const E& error() const & noexcept;`
>
> `constexpr E& error() & noexcept;`
>
> [7]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `false`.
>
> [8]{.pnum} _Returns_: _`unex`_.

Modify [expected.void.obs]{.sref} paragraph 9 as indicated:

> `constexpr E&& error() && noexcept;`
>
> `constexpr const E&& error() const && noexcept;`
>
> [9]{.pnum} _[Hardened]{.add} [P]{.rm}[p]{.add}reconditions_: `has_value()` is `false`.
>
> [10]{.pnum} _Returns_: `std::move(`_`unex`_`)`.

## Feature-test macros

(Authors' note: we are not attached to any particular way of defining the feature-test macros. The proposed wording adds a macro for each class that would now contain hardened preconditions, but we are very open to suggestions on how these macros may be combined or split further, as well as naming)

Add a new paragraph to [version.syn]{.sref} after paragraph 2 as indicated:

::: add
> [?]{.pnum} Additionally, each of the following macros are defined in a hardened implementation:
:::

```diff
+ #define __cpp_lib_hardened_array                    20????L // also in <array>
+ #define __cpp_lib_hardened_basic_string             20????L // also in <string>
+ #define __cpp_lib_hardened_basic_string_view        20????L // also in <string_view>
+ #define __cpp_lib_hardened_bitset                   20????L // also in <bitset>
+ #define __cpp_lib_hardened_deque                    20????L // also in <deque>
+ #define __cpp_lib_hardened_expected                 20????L // also in <expected>
+ #define __cpp_lib_hardened_forward_list             20????L // also in <forward_list>
+ #define __cpp_lib_hardened_inplace_vector           20????L // also in <inplace_vector>
+ #define __cpp_lib_hardened_list                     20????L // also in <list>
+ #define __cpp_lib_hardened_mdspan                   20????L // also in <mdspan>
+ #define __cpp_lib_hardened_optional                 20????L // also in <optional>
+ #define __cpp_lib_hardened_span                     20????L // also in <span>
+ #define __cpp_lib_hardened_valarray                 20????L // also in <valarray>
+ #define __cpp_lib_hardened_vector                   20????L // also in <vector>
```
> [?]{.pnum} The macro `__cpp_lib_freestanding_operator_new` is defined to the integer literal `202306L` if all the default versions of the replaceable global allocation functions meet the requirements of a hosted implementation, and to the integer literal `0` otherwise ([new.delete]).

> [?]{.pnum} _Recommended practice_: Freestanding implementations should only define a macro from `<version>` if the implementation provides the corresponding facility in its entirety.

> [[?]{.pnum} _Recommended practice_: A non-hardened implementation should not define macros from `<version>` required for hardened implementations.]{.add}
