---
title: "Cleaning up the trivial relocation APIs in C++26"
document: D3631R0
date: 2025-02-13
audience: LEWG
author:
  - name: Louis Dionne
    email: <ldionne.2@gmail.com>
  - name: Giuseppe D'Angelo
    email: <giuseppe.dangelo@kdab.com>
toc: true
toc-depth: 2
---

# Introduction

[P3516][] was design-approved by LEWG in Hagenberg. As part of that discussion, we also discussed cleaning up the
relocation-related APIs provided in the library (since [P2786][] also added some), but we decided to punt it to
a separate paper to allow P3516 to progress. This is the cleanup paper.

# Proposal

The current state of the APIs that have been design-approved by LEWG is this:

```c++
// P2786 APIs
template <class T>
T* trivially_relocate(T* first, T* last, T* result);

template <class T>
T* trivially_relocate_at(T* location, T* source);

template <class T>
constexpr T* relocate(T* first, T* last, T* result);

// P3516 APIs
template<class T>
 requires @_relocatable-from_@<T, T>
  constexpr T* relocate_at(T* dest, T* source)
    noexcept(is_nothrow_relocatable_v<T>);

template<class NoThrowForwardIterator1, class NoThrowForwardIterator2>
  constexpr NoThrowForwardIterator2
    uninitialized_relocate(NoThrowForwardIterator1 first,
                           NoThrowForwardIterator1 last,
                           NoThrowForwardIterator2 result);

template<class NoThrowForwardIterator1, class Size, class NoThrowForwardIterator2>
  constexpr pair<NoThrowForwardIterator1, NoThrowForwardIterator2>
    uninitialized_relocate_n(NoThrowForwardIterator1 first,
                             Size n,
                             NoThrowForwardIterator2 result);

template<class NoThrowBidirectionalIterator1, class NoThrowBidirectionalIterator2>
  constexpr NoThrowBidirectionalIterator2
    uninitialized_relocate_backward(NoThrowBidirectionalIterator1 first,
                                    NoThrowBidirectionalIterator1 last,
                                    NoThrowBidirectionalIterator2 result);

// ... also std::execution_policy overloads ...

namespace ranges {
  // ... similar overloads here ...
}
```

We propose:

- Removing `std::relocate(...)`. It was introduced before we had proper relocation algorithms, and it's
  basically a less capable version of the uninitialized algorithms above since it doesn't support iterators
  and potentially-throwing move constructors. One difference is that `std::relocate(...)` does detect overlaps
  and decides to relocate forward or backward, which [P3516][] handles by having a `_backward` variant instead
  (which is consistent with existing uninitialized algorithms).
- Removing `std::trivially_relocate_at`. It's a less capable version of `std::relocate_at`. If you use
  `std::relocate_at` with trivially relocatable types only, what you have is exactly `std::trivially_relocate_at`.
- Making `std::trivially_relocate` an exposition-only helper. We don't want to encourage users to call it, instead they
  should make use of the (safer) algorithms that take iterators and handle exceptions properly. We do not lose any
  functionality, since `std::uninitialized_relocate` is basically equivalent to it for trivially relocatable types
  (modulo the detection of overlap). Note that we need to keep that function as exposition-only because it defines
  important core-language wording for trivial relocation, and [P3516][] uses it. We could potentially make it a
  function working on a single element instead, since that's what [P3516][]'s `std::relocate_at` requires, but we
  are not attached to that.

[P2786]: https://wg21.link/P2786
[P3516]: https://wg21.link/P3516
