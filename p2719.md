---
title: "Type-aware allocation and deallocation functions"
document: P2719R1
date: 2024-10-16
audience: Evolution
author:
  - name: Louis Dionne
    email: <ldionne@apple.com>
  - name: Oliver Hunt
    email: <oliver@apple.com>
toc: false
toc-depth: 4
---

# Introduction

C++ currently provides two ways of customizing the creation of objects in new expressions. First, `operator new` can
be provided as a static member function of a class, like `void* T::operator new`. If such a declaration is provided, an
expression like `new T(...)` will use that allocation function. Otherwise, the global version of `operator new` can be
replaced by users in a type-agnostic way, by implementing `void* operator new(size_t)` and its variants. A similar
mechanism exists for _delete-expressions_.

This paper proposes an extension to _new-expressions_ and _delete-expressions_ to provide the concrete type being
[de]allocated to the allocation functions. This is achieved via the use of an additional `std::type_identity<T>`
tag argument that allows the provision of the concrete type to `operator new` and `operator delete`. In addition to
providing valuable information to the allocator, this allows the creation of type-specific `operator new` and
`operator delete` for types that cannot have intrusive class-scoped operators specified.

At a high level, this allows defining allocation and deallocation functions like:

```cpp
void* operator new(std::type_identity<mylib::Foo>, std::size_t n) { ... }
void operator delete(std::type_identity<mylib::Foo>, void* ptr) { ... }
```

However, it also allows providing these functions for a family of types, which is where this feature becomes
interesting:

```cpp
template <class T>
  requires usable_with_custom_allocator<T>
void* operator new(std::type_identity<T>, std::size_t n) { ... }

template <class T>
  requires usable_with_custom_allocator<T>
void operator delete(std::type_identity<T>, void* ptr) { ... }
```

# Revision history

- R0: Initial version
- R1 (based on St-Louis feedback and implementation experience):
  - Simplified the lookup mechanism by removing the need to perform ADL
  - Allowed `std::type_identity` parameter for in-class `T::operator new` for consistency
  - Added justification for taking `std::type_identity<T>` instead of `T*` as a first argument.
  - LOUIS: TODO: Added explanation of what happens w.r.t. ODR and mismatched new/delete operators
  - LOUIS: TODO: Mention interactions with `std::allocator` and that we can resolve that separately
  - Added justification for not allowing type-aware destroying delete

# Motivation

Knowledge of the type being [de]allocated in a _new-expression_ is necessary in order to achieve certain levels of
flexibility when defining a custom allocation function. However, even when defining `T::operator new` in-class, the
only information available to the implementation is the type declaring the operator, not the type being allocated.
This results in developers various creative (often macro-based) mechanisms to define these allocation functions manually,
or circumventing the language-provided allocation mechanisms entirely in order to track the allocated types.

However, in addition to these intrusive mechanisms being cumbersome and error-prone, they do not make it possible to
customize how allocation is performed for types controlled by a third-party, or to customize allocation for an open
set of types.

Beyond these issues, a common problem in we see in the wild is codebases overriding the global (and untyped) `operator new`
via the usual link-time mechanism and running into problems because they really only intended for their custom
`operator new` to be used within their own code, not by all the code in their process. For example, we've seen scenarios
where multiple libraries attempt to replace the global `operator new` and end up with a complex ODR violation bug that
depends on how the dynamic linker resolved weak definitions at load time -- not very user friendly. By providing the
concrete type information to allocators at compile time, it becomes possible for authors to override `operator new`
for a family of types that they control without overriding it for the whole process, which is what they _actually_ want.

## A concrete use case

A few years ago, Apple published [a blog post](https://security.apple.com/blog/towards-the-next-generation-of-xnu-memory-safety)
explaining a technique used inside its kernel (XNU) to mitigate various exploits. At its core, the technique roughly
consists in allocating objects of each type in a different bucket. By collocating all objects of the same type into the
same region of memory, it becomes much harder for an attacker to exploit a type confusion vulnerability. Since its
introduction in the kernel, this technique alone has been by far the most effective at mitigating type confusion
vulnerabilities.

In a world where security is increasingly important, it may make sense for some code bases to adopt mitigation techniques
such as this one. However, these techniques require a large-scale and _almost_ system-wide customization of how allocation
is performed while retaining type information, which is not supported by C++ today. While not sufficient in itself to make
C++ safer, the change proposed in this paper is a necessary building block for technology such as the above which can
greatly improve the security of C++ applications.

# Current behavior recap

Today, the compiler performs [a lookup](https://timsong-cpp.github.io/cppwp/n4950/expr.new#12) in the allocated type's class
scope (for `T::operator new`), and then a lookup in the global scope (for `::operator new`) if the previous one failed. Once
the name lookup has been done and the compiler has decided whether it was looking for `T::operator new` or `::operator new`,
name lookup will not be done again even if the steps that follow were to fail. From here on, let's denote by `NEW` the
set of candidates found by the name lookup process.

The compiler then performs [overload resolution](https://timsong-cpp.github.io/cppwp/n4950/expr.new#19) on that set of
candidates using the language-specified optional implicit parameters, and if present any developer-provided placement
arguments. It does so by assembling an argument list that depends on whether `T` has a new-extended alignment or not.
For the sake of simplicity, assume that `T` does not have a new-extended alignment. The compiler starts by performing
overload resolution as-if the following expression were used:

```cpp
NEW(sizeof(T), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the compiler performs overload resolution
again as-if the following expression were used:

```cpp
NEW(sizeof(T), std::align_val_t(alignof(T)), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the program is ill-formed. For a type `T`
that has new-extended alignment, the order of the two overload resolutions performed above is simply reversed.

Delete-expressions behave similarly, with lookup being performed in the context of the dynamic type of the object, in
case it differs from its static type. The overload resolution process then works by preferring a destroying delete,
followed by an aligned delete (if the type has new-extended alignment), followed by the usual `operator delete` (with
or without a `size_t` parameter depending on whether the considered `operator delete` is a member function or not).

# Proposal

This proposal adds a new implicit tag argument of type `std::type_identity<T>` to `operator new` and `operator delete`
that is incorporated into the existing overload resolution logic with a higher priority than existing implicit parameters.
To avoid conficts with existing code, this parameter is placed as the first argument to the operator, preceding the size or
subject pointer. To avoid the complexities of ADL, this proposal does not change any of the _name lookup_ rules associated
to _new_ and _delete_ expressions: it only changes the overload resolution that happens once a name has been found.

For the declaration of a type aware [de]allocation operator to be valid, we explicitly require that the parameter be a
(potentially dependent) specialization of `std::type_identity`, but not a fully dependent type. In other words, the
compiler must be able to tell that the first parameter is of the form `std::type_identity<T>` at the time of parsing
the declaration, but before the declaration has been instantiated in the case of a template. This is analogous to the
current behavior where we require specific concrete types in the parameter list even in dependent contexts.

Once a set of candidate declarations has been found we perform the same prioritized overload resolution steps,
only with the addition of `std::type_identity<T>`, with a higher priority than the existing size and alignment
parameters. For illustration, here is how overload resolution changes (`NEW` is the set of candidates found by
name lookup for `operator new`, and `DELETE` is the equivalent for `operator delete`):

If the user writes `new T(...)`, the compiler checks (in order):

::: cmptable

### Before

```cpp
// assuming T not overaligned
NEW(size_t)
```

### After

```cpp
// assuming T not overaligned
NEW(type_identity<T>, size_t)
NEW(size_t)
```

---

```cpp
// assuming T overaligned
NEW(size_t, align_val_t)
NEW(size_t)
```

```cpp
// assuming T overaligned
NEW(type_identity<T>, size_t, align_val_t)
NEW(type_identity<T>, size_t)
NEW(size_t, align_val_t)
NEW(size_t)
```

:::

If the user writes `delete ptr`, the compiler checks (in order):

::: cmptable

### Before

```cpp
// assuming T not overaligned
DELETE(DefiningClass*, destroying_delete_t, ...)
DELETE(void*, size_t)
DELETE(void*)
```

### After

```cpp
// assuming T not overaligned
DELETE(DefiningClass*, destroying_delete_t, ...)
DELETE(type_identity<T>, void*, size_t)
DELETE(type_identity<T>, void*)
DELETE(void*, size_t)
DELETE(void*)
```

---

```cpp
// assuming T overaligned
DELETE(DefiningClass*, destroying_delete_t, ...)
DELETE(void*, size_t, align_val_t)
DELETE(void*, align_val_t)
DELETE(void*)
```

```cpp
// assuming T overaligned
DELETE(DefiningClass*, destroying_delete_t, ...)
DELETE(type_identity<T>, void*, size_t, align_val_t)
DELETE(type_identity<T>, void*, align_val_t)
DELETE(type_identity<T>, void*)
DELETE(void*, size_t, align_val_t)
DELETE(void*, align_val_t)
DELETE(void*)
```

:::

If multiple candidates match a given set of parameters, candidate prioritisation and selection is performed
according to usual rules for overload resolution.

When a constructor throws an exception, a call to `operator delete` is made to clean up. Overload resolution for this
call remains essentially the same, the only difference being that the selected `operator delete` must have the same
type-awareness as the preceding `operator new` or the program is considered ill-formed.

## Free function example

```cpp
struct SingleClass { };
struct UnrelatedClass { };
struct BaseClass { };
struct SubClass1 : BaseClass { };
struct SubClass2 : BaseClass { };
struct SubClass3 : BaseClass { };
void* operator new(std::type_identity<SingleClass>, std::size_t); // (1)
template <typename T> void* operator new(std::type_identity<T>, std::size_t); // (2)

template <std::derived_from<BaseClass> T>
void* operator new(std::type_identity<T>, std::size_t); // (3)
void* operator new(std::type_identity<SubClass2>, std::size_t); // (4)
void* operator new(std::type_identity<SubClass3>, std::size_t) = delete; // (5)

struct SubClass4 : BaseClass {
  void *operator new(size_t); // (6)
};

void f() {
  new SingleClass();     // calls (1)
  new UnrelatedClass();  // calls (2)
  new BaseClass();       // calls (3) with T=BaseClass
  new SubClass1();       // calls (3) with T=SubClass1
  new SubClass2();       // calls (4)
  new SubClass3();       // resolves (5) reports error due to deleted operator
  new SubClass4();       // calls (6) as the class scoped operator wins
  new int();             // calls (2) with T=int
}
```

> Note: The above is for illustrative purposes only: it is a bad idea to provide a fully unconstrained type-aware `operator new`.

## In-class example
```cpp
// In class operator
class SubClass1;
struct BaseClass {
  template <typename T>
  void* operator new(std::type_identity<T>, std::size_t); // (1)
  void* operator new(std::type_identity<SubClass1>, std::size_t); // (2)
};

struct SubClass1 : BaseClass { };
struct SubClass2 : BaseClass { };
struct SubClass3 : BaseClass {
  void *operator new(std::size_t); // (3)
};
struct SubClass4 : BaseClass {
  template <typename T>
  void *operator new(std::type_identity<T>, std::size_t); // (4)
};

void f() {
  new BaseClass;         // calls (1) with T=BaseClass
  new SubClass1();       // calls (2)
  new SubClass2();       // calls (1) with T=SubClass2
  new SubClass3();       // calls (3)
  new SubClass4();       // calls (4) with T=SubClass4
  ::new BaseClass();     // ignores in-class operators and uses appropriate global operator
}
```

<!--
# Wording

To effectively support this proposal, it is necessary to update the definition of a usual deallocation function
([basic.stc.dynamic.deallocation](https://timsong-cpp.github.io/cppwp/n4950/basic.stc.dynamic.deallocation)) to
include this new parameter, which requires the following:

* Allow the first parameter to be a specialization of `std::type_identity`, and update to position requirements of later
  parameters to include that.
* Allow the function to have template parameters as long as the function is `operator delete` and the
  only dependent parameter is a `std::type_identity` specialization in the first parameter position.
-->

# Design choices and notes

## Impact on the library

This proposal does not have any impact on the library, since this only tweaks the search process performed by the
compiler when it evaluates a new-expression and a delete-expression. In particular, we do not propose adding new
type-aware free function `operator new` variants in the standard library at this time, althought this could be
investigated in the future.

## Design choice: Template argument vs tag parameter

In an earlier draft, this paper was proposing the following (seemingly simpler) mechanism instead. Instead of
reusing `std::type_identity` as a tag parameter, the compiler would search as per the following expression:

```cpp
operator new<T>(sizeof(T), args...)
```

The only difference here is that we're not passing `std::type_identity` as a first argument and we are passing
it as a template argument instead. Unfortunately, this has a number of problems, the most significant of which
is that without a tag parameter it is not possible to distinguish a type aware allocation operator from existing
template operator declarations.

The first problem of note is we want to support type aware deallocation functions as usual deallocation functions.
Without an explicit type tag this distinction is not possible which leaves us unable to distinguish a type aware deallocation function from any other templated `operator delete`. Absent this distinction this feature would
create the risk of inappropriately calling `operator delete` implementations in existing code bases in scnerios
they have not previously been invoked.

In addition to this issue, there are also questions of how these semantics interact with existing templated
operators, as an example

```cpp
template <class ...Args>
void operator delete(void *, Args...);
size_t *sz_ptr = ...;
delete sz_ptr;
```

Because in this model allocation of a type aware operator must be explicit, we will explicitly instantiate
this as `operator delete<size_t>` as a type aware allocator, and in doing so this would also be validly
interpreted as a size aware deallocator. It is unclear which would be preferred - if either - but for existing
code this is the difference between the candidate being a valid usual deallocation function or not, so this
semantic change (althought theoretically not encounterable in this specific example) could introduce calls to
deletion operators where previously none occurred.

Finally, using a tag parameter allows a developer to more easliy specify allocation apis that are constrained
to specific concrete types. There are cases where a developer may not be able to specify in class allocation
operators, and being able to specify free operators with explict type constraints resolves this problem, e.g.

Without a tag parameter a developer in this position is required to write code similar to:

```cpp
struct S { ... };
template <typename T, typename = std::enable_if_t<std::is_same_v<T, S>>>
void *operator new(size_t);
```

Whereas with a tag they can simply specify the restriction explicity

```cpp
struct S { ... };
void *operator new(std::type_identity<S>, size_t);
```

While this last example is a minor nicety for developers, it is something we have considered.

Taken together we believe these issues warrant the use of an explicit tag parameter.

## Design choice: Use of `std::type_identity<T>` vs `T*`

In this proposal we have used `std::type_identity<T>` rather than using the outwardly simpler option of `T*`.

This perceived simplicity hides an array of subtle problems that are avoided through the use of `std::type_identity`.

### Problems with the value being passed
The first problem is the value that is passed as the tag parameter. Given an allocator signature of the form

```cpp
template <class T> void *operator new(T*, size_t) { ... }
template <class T> void operator delete(T*, void *) { ... }
```

A developer could reasonably be assumed to understand that the tag parameter to `operator new` would necessarily
be a null pointer, but for operator delete we can be assured that people will be confused about receiving two
pointer parameters, where the explicitly typed parameter is null. However we cannot pass the object pointer through
this parameter as this operator is called after the object has been destroyed, so providing the original pointer
would be an invitation to guaranteed undefined behaviour.

### Problems with implicit capture of subtypes

A scenario we have discussed is developers wishing to provide custom allocators for specific types,
when using a typed pointer as the tag, this would be written as

```cpp
struct S;
void *operator new(S*, size_t) { ... }
```

However this operator will also match any subtypes of `S`, which may be intended, but if it is not
intended the conversion from `Subtype*` to `S*` is entirely silent and may not be noticed. The robust
solution for this requires a reversion to the tag-free design above, i.e

```cpp
template <typename T, typename = std::enable_if_t<std::is_same_v<T, S>>>
void *operator new(T*, size_t);
```

### Performance considerations

There is a fundamental difference between `T*` and `std::type_identity<T>` in that `T*` is a type that
has an actual value and size, whereas `std::type_identity` is a zero sized record. This difference means
that the `T*` model results in an additional parameter being required in the generated code, whereas
the zero sized `type_identity` parameter does not exist in the majority of calling conventions.
In principle this difference should be minor for templated operators as they are typically inlined and
so the calling convention is not relevant, but for non-template definitions the implementation can be
out of line, and so the difference may matter.

## Design choice: Order of arguments

When writing this paper, we went back and forth of the order of arguments. This paper proposes:

```c++
operator new(std::type_identity<T>, std::size_t, placement-args...)
operator new(std::type_identity<T>, std::size_t, std::align_val_t, placement-args...)

operator delete(std::type_identity<T>, void*)
operator delete(std::type_identity<T>, void*, std::size_t)
operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t)
```

Another approach would be:

```c++
operator new(std::size_t, std::type_identity<T>, placement-args...)
operator new(std::size_t, std::align_val_t, std::type_identity<T>, placement-args...)

operator delete(void*, std::type_identity<T>)
operator delete(void*, std::size_t, std::type_identity<T>)
operator delete(void*, std::size_t, std::align_val_t, std::type_identity<T>)
```

The existing specification allows for the existence of template (including variadic template) declarations of
operator new and delete, and this functionality is used in existing code bases. This leads to problems compiling
real world code where overload resolution will allow selection of a non-SFINAE-safe declaration, and subsequently
breaks during compilation.

Placing the type tag preceding the size or pointer argument ensures that no existing operator definition can
match this new tag, and so we are guaranteed to be free from conflict.

An alternative to this would be to require passing an implicit `type_identity` parameter to require the relevant
parameter in the original function declaration always be a `type_identity<T>` specialization, similar to our
definition of type aware allocators in general. This would differ from the behavior with respect to other implicit
parameters that are permitted to bind to arbitrary template parameters.

## Design choice: Allowing template type aware `operator delete` as a usual deallocation function

Allowing type aware `operator delete` does require changes to the definition of usual deallocation functions,
but the changes are conceptually simple and the cost of not supporting this case is extremely high.

In the current specification we already place very tight requirements on what the type of an `operator delete`
definition must be in order to be considered a "usual deallocation function". The reason these definitions have
not allow template functions previously is because all of the implicit parameters are monomorphic types. In that
environment such a restriction makes sense.

However in this proposal we have introduced an implicit parameter that for which it is correct, and
expected, for the method to be templated. To that end we allowed a template `operator delete` to be
considered a usual deallocation function, as long as the only dependently typed parameter is the implicit
`type_identity` parameter. To our minds, these semantics match the "intent" of the restrictions already in
place for the other implicit parameters.

The cost of not allowing template type aware `operator delete` as a usual deallocation function is very high,
as it functionally prohibits the use of type aware allocation operators in any environment that depends of
being able to use usual deallocation functions. This is any environment where it is expected that constructors
may throw exceptions, and depend on object clean up, a condition that applies across from many custom "drop in"
allocator libraries all the way to general system allocators.

## Design choice: Non-support for type-aware destroying delete

We have decided not to support type aware destroying delete as we believe it creates a user hazard. At a
technical level there is no additional complexity in supporting type aware destroying delete, but the
resulting semantics seem likely to cause a high risk of user confusion, for example given this hypothetical
declaration

```cpp
struct Foo {
  ...
  template <class T> void operator delete(type_identity<T>, Foo*, std::destroying_delete_t);
};

struct Bar : Foo {

};

void f(Foo* f) {
  delete f; // calls Foo::operator delete<Foo>
}
void g(Bar *b) {
  delete b; // calls Foo::operator delete<Bar>
}
```

To a user this appears to be doing what they expect, but if we introduce the following

```cpp
struct Oops : Bar {

};

void h(Oops *o) {
  g(o);
}
```

By design, destroying delete does not perform any polymorphic dispatch, and as a result
the type being passed to the operator may not be the true concrete type of the object
being destroyed, but rather it would just be the type of the pointer being operated over.
As a result in many basic tests it will appear to be "correct" from the user's point of
view, but there is no guarantee that that will always be the case. Furthermore, even in
the case where a user were to exhuastively test their code base at one time, the addition
of any new subtypes in future would silently introduce the potential for a mismatch.

## Design choice: ADL

The initial proposal allowed the specification of type aware allocators in namespaces that could
then be resolved via ADL. Upon further consideration this introduces a number of hazards to the
language that are complex to resolve robustly and as a result we have dropped support for
namespaced allocator declarations and removed the use of ADL from the proposal.

The first problem is declarations discovered from ADL over placement arguments. For operator new
these are not a problem, however the delete operator does not support placement arguments, so the
search scope can be significantly different between `new (args) Type` and the subsequent
`delete Object`.

Our hope was that by allowing namespaced operators we would simplify the work of constraining for
a library to constrain a custom allocator to just the types in that library, however there exist
myriad mechanisms by which a simple namespace only constraint is unintentionally expanded, the most
trivial of which is `new Namespace1::Type<Namespace2::Type>`. As a result a conscientious developer
will always need to appropriately constrain their type aware API, even if they were scoped.

As that work is functionally always required, the addition of ADL to the search phase does not
meaningfully improve the developer experience, and it introduces a hazard wherein a developer is not
aware that simply namespacing the declarations is insufficient - it will frequently appear to work
as expected - whereas there is already a strong understanding of the work involved in exposing and
overriding global allocation functions.
