---
title: "Type-aware allocation and deallocation functions"
document: P2719R0
date: 2024-05-18
audience: Evolution
author:
  - name: Louis Dionne
    email: <ldionne@apple.com>
  - name: Oliver Hunt
    email: <oliver@apple.com>
toc: false
toc-depth: 4
---

# Introduction

C++ currently provides two ways of customizing the creation of objects in new expressions. First, `operator new` can
be provided as a static member function of a class, like `void* T::operator new`. If such a declaration is provided, an
expression like `new T(...)` will use that allocation function. Otherwise, the global version of `operator new` can be
replaced by users in a type-agnostic way, by implementing `void* operator new(size_t)` and its variants. A similar
mechanism exists for _delete-expressions_.

This paper proposes an extension to _new-expressions_ and _delete-expressions_ to provide the concrete type of an
allocation or deallocation to the allocation functions. This is achieved via the addition of an additional tag argument
of type `std::type_identity<TypeBeingAllocated>` that allows the provision of the concrete type to `operator new` and
`oeprator delete`. This allows the addition of type specific implementations of `operator new` and `operator delete` for
types that cannot have invasive class scoped allocators specified, and allows accurate type information to be provided
when allocating subtypes.

To add further convenience to these models, we also propose allowing these type aware interfaces to be namespace scoped,
and add an additional ADL lookup for new and delete operator based on the type being allocated.

::: cmptable

### Before
```cpp
// user writes:
new (args...) T(...)

// compiler checks:
{{DeclScope = (T specifies operator new) ? T : Global}}
DeclSpace::operator new(sizeof(T), align_val_t(alignof(T)), args...) // (1)
DeclSpace::operator new(sizeof(T), args...)  // (2)
```

### After
```cpp
// user writes:
new (args...) T(...)

// compiler checks:
DeclSpace::operator new(std::type_identity\<T\>, sizeof(T), align_val_t(alignof(T)), args...) // (1)
DeclSpace::operator new(std::type_identity\<T\>, sizeof(T)), args...) // (1)
DeclSpace::operator new(sizeof(T), align_val_t(alignof(T)), args...) // (1)
DeclSpace::operator new(sizeof(T), args...)  // (2)
```

:::

::: cmptable
// TODO: Update remainder of examples
### Before
```cpp
// user writes:
new (args...) T[n]

// compiler checks:
T::operator new[](n * sizeof(T), args...) // (1)
::operator new[](n * sizeof(T), args...)  // (2)
```

### After
```cpp
// user writes:
new (args...) T\[n\];

// compiler checks:
T::operator new\[\](n * sizeof(T), args...) // (1)
@[operator new\[\](n * sizeof(T), std::type_identity\<T\>, args...)]{.add}@ // (2)
::operator new\[\](n * sizeof(T), args...)  // (3)
```

:::

::: cmptable

### Before
```cpp
// user writes:
delete obj

// compiler checks:
// TODO: Myriad align and size parameters
{{DeclSpace = (T specifies operator new) ? T : Global + ADL_lookup(T)}}
DeclSpace::operator delete(T*, destroying_tag_t)
DeclSpace::operator delete(void-ptr)  // (2)
```

### After
```cpp
// user writes:
delete ptr

// compiler checks:
// TODO: Myriad align and size parameters
{{DeclSpace = (T specifies operator new) ? T : Global}}
DeclSpace::operator delete(std::type_identity\<T\>, T*, destroying_tag_t)
DeclSpace::operator delete(std::type_identity\<T\>, void-ptr)  // (2)
DeclSpace::operator delete(T*, destroying_tag_t)
DeclSpace::operator delete(void-ptr)  // (2)
```

:::

::: cmptable
// TODO: Update these
### Before
```cpp
// user writes:
delete[] ptr

// compiler checks:
T::operator delete[](void-ptr) // (1)
::operator delete[](void-ptr)  // (2)
```

### After
```cpp
// user writes:
delete[] ptr

// compiler checks:
T::operator delete[](void-ptr) // (1)
@[operator delete[](void-ptr, std::type_identity\<T\>)]{.add}@ // (2)
::operator delete[](void-ptr)  // (3)
```

:::

# Motivation

Knowledge of the type being allocated in a _new-expression_ is necessary in order to achieve certain levels of flexibility
when defining a custom allocation function. However, requiring an intrusive in-class definition to achieve this is not
realistic in various circumstances, for example when wanting to customize allocation for types that are controlled by a
third-party, or when customizing allocation for a very large number of types. Even when in-class definitions are an option,
the existing specification does not provide a mechanism to support concrete type information when allocating and deallocating
subtypes.

In the wild, we often see code bases overriding the global (and untyped) `operator new` via the usual link-time mechanism
and running into issues because they really only intended for their custom `operator new` to be used within their own code,
not by all the code in their process. We also run into issues where multiple libraries attempt to replace the global
`operator new` and end up with a complex ODR violation bug.

The changes proposed by this paper provide a mechanism for code bases to implement smarter and more secure allocators,
and to more easily implement what they _actually_ want, which is to override `operator new` for a family of types that they
control without overriding it for the whole process. The overriding also happens at compile-time instead of link-time, which
is both supported by all known implementations (unlike link-time) and better understood by users than e.g. weak definitions.

## A concrete use case

A few years ago, Apple published [a blog post](https://security.apple.com/blog/towards-the-next-generation-of-xnu-memory-safety)
explaining a technique used inside its kernel (XNU) to mitigate various exploits. At its core, the technique roughly consists in
allocating objects of each type in a different bucket. By collocating all objects of the same type into the same region of
memory, it becomes much harder for an attacker to exploit a type confusion vulnerability. Since its introduction in the kernel,
this technique alone has been by far the most effective at mitigating type confusion vulnerabilities.

In a world where security is increasingly important, it may make sense for some code bases to adopt mitigation techniques
such as this one. However, these techniques require a large-scale and _almost_ system-wide customization of how allocation
is performed while retaining type information, which is not supported by C++ today. While not sufficient in itself to make
C++ safer, the change proposed in this paper is a necessary building block for technology such as the above which can greatly
improve the security of C++ applications.

# Current behavior recap

Today, the compiler performs [a lookup](https://timsong-cpp.github.io/cppwp/n4950/expr.new#12) in the allocated type's class
scope (for `T::operator new`), and then a lookup in the global scope (for `::operator new`) if the previous one failed. Once
the name lookup has been done and the compiler has decided whether it was looking for `T::operator new` or `::operator new`,
name lookup will not be done again even if the steps that follow were to fail.

The compiler then performs [overload resolution](https://timsong-cpp.github.io/cppwp/n4950/expr.new#19) on the name it found
in the previous step (let's call that name `NEW`) by assembling an argument list that depends on whether `T` has a new-extended
alignment or not. For the sake of simplicity, assume that `T` does not have a new-extended alignment. The compiler starts by
performing overload resolution as-if the following expression were used:

```cpp
NEW(sizeof(T), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the compiler performs overload resolution
again as-if the following expression were used:

```cpp
NEW(sizeof(T), std::align_val_t(alignof(T)), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the program is ill-formed. For a type `T`
that has new-extended alignment, the order of the two overload resolutions performed above is simply reversed.

Delete-expressions behave similarly, with lookup being performed in the context of the dynamic type of the object, in
case it differs from its static type. The overload resolution process then works by preferring a destroying delete,
followed by an aligned delete (if the type has new-extended alignment), followed by the usual `operator delete` (with
or without a `size_t` parameter depending on whether the considered `operator delete` is a member function or not).

# Proposal

This proposal adds a new implicit tag argument of type `std::type_identity<T>` to `operator new` and `operator delete` that
is incorporated into the existing declaration preference logic with a higher priority than existing implicit parameters.
To avoid potential conficts with existing code, this parameter is placed as the first argument to the operator, preceding
the size or subject pointer. For such a declaration to be valid we require that the parameter be explicitly a specialization
of `std::type_identity`, and not a fully dependent type.

**terminology?**
i'm wanting to say these are correct:
void* operator new(std::type_identity<Foo>, size_t, ...);
template <typename T> void* operator new(std::type_identity<T>, size_t, ...);
template <typename T> void* operator new(std::type_identity<Foo<T>>, size_t, ...);


but these are not:

template <typename T> void* operator new(T, size_t, ...); // even if invoked with `operator new<type_identity<int>>`
template <typename T> struct S { void* operator new(T, size_t, ...); }; S<std::type_identity<int>>
template <template<typename> typename T> void* operator new(T<int>, size_t, ...); // even if invoked with `operator new<std::type_identity>
etc
**end note**

We will refer to operator new and delete declarations of this form as "type aware allocation operators".

To reduce leakage into the global scope, this proposal now allows type aware allocation operators to be declared within
a namespace. **Note: i feel we should be able to specify semantics such that `new X` and `delete someX` require the
resolved operator new and delete come from the same scope as at least a basic correctness guard**


Currently during operator resolution, if no in-class declaration is discovered we continue our search in the global scope.
In our proposal if no in-class declaration of the requested operator is found we replace the current global scope look up
with an ADL lookup over the implicit parameters.


To effectively support this new tag it is necessary to update the definition of a usual deallocation function ([basic.stc.dynamic.deallocation]) to:

* Allow type aware allocation operators. This means allowing the `std::type_identity` parameter, and updating the current spec text to allow for the change in later parameter positions
* Allow the operator to have template arguments, as long as the only the first parameter is dependent, and it is type aware operator.

Once a set of candidate declarations has been found we perform the same priorities overload resolution steps, only with
the addition of the type_identity tag, with a higher priority than the existing size and alignment parameters. This gives
us the following overload resolution ordering for operator new:

```cpp
1. NEW(type_identity<T>(), sizeof(T), align_val_t(alignof(T)), args...)
2. NEW(type_identity<T>(), sizeof(T), args...)
3. NEW(sizeof(T), align_val_t(alignof(T)), args...)
4. NEW(sizeof(T), args...)
```

When a constructor throws an exception, a cleanup call is made to `operator delete`. The semantics of this cleanup
resolution remain essentially the same, the only difference being that the `operator delete` selected during overload
resolution must have the same type awareness as the preceding `operator new` or the program is considered ill formed.

Overload resolution for delete expressions is effectively the same, only with minor variations on parameter types

```cpp
1. If destroying delete is applicable:
  1. DELETE(type_identity<T>(), <Destroying Type>*, destroying_delete_tag_t(), sizeof(T), align_val_t(alignof(T)))
  2. DELETE(type_identity<T>(), <Destroying Type>*, destroying_delete_tag_t(), sizeof(T))
  3. DELETE(type_identity<T>(), <Destroying Type>*, destroying_delete_tag_t())
  4. DELETE(<Destroying Type>*, destroying_delete_tag_t(), sizeof(T), align_val_t(alignof(T)))
  5. DELETE(<Destroying Type>*, destroying_delete_tag_t(), sizeof(T))
  6. DELETE(<Destroying Type>*, destroying_delete_tag_t())
2. DELETE(type_identity<T>(), void*, sizeof(T), align_val_t(alignof(T)))
3. DELETE(type_identity<T>(), void*, sizeof(T))
4. DELETE(type_identity<T>(), void*)
5. DELETE(void*, sizeof(T), align_val_t(alignof(T)))
6. DELETE(void*, sizeof(T))
7. DELETE(void*)
```

## Example

// TODO: Update these examples

```cpp
namespace lib {
  struct Foo { };
  void* operator new(std::size_t, std::type_identity<Foo>); // (1)

  struct Foo2 { };
}

void* operator new(std::type_identity<Foo>, std::size_t); // (1)

struct Bar {
  static void* operator new(std::size_t); // (2)
};

void* operator new(std::size_t); // (3)

void f() {
  new lib::Foo();  // calls (1)
  new Bar();       // calls (2)
  new lib::Foo2(); // (1) is seen but fails overload resolution, we end up calling (3)
  new int();       // calls (3)
}
```

# Design choices and notes

## Impact on the library

This proposal does not have any impact on the library, since this only tweaks the search process performed by the
compiler when it evaluates a new-expression and a delete-expression. In particular, we do not propose adding new
type-aware free function `operator new` variants in the standard library at this time, althought this could be
investigated in the future.

## Design choice: Order of arguments

** [oliver] NOTE: i think we should switch to type_identity first as it ensures existing code cannot conflict**

When writing this paper, we went back and forth of the order of arguments. This paper proposes:

```c++
operator new(std::size_t, std::type_identity<T>, placement-args...)
operator new(std::size_t, std::align_val_t, std::type_identity<T>, placement-args...)

operator delete(void*, std::type_identity<T>)
operator delete(void*, std::size_t, std::type_identity<T>)
operator delete(void*, std::size_t, std::align_val_t, std::type_identity<T>)
```

Another approach would be:

```c++
operator new(std::type_identity<T>, std::size_t, placement-args...)
operator new(std::type_identity<T>, std::size_t, std::align_val_t, placement-args...)

operator delete(std::type_identity<T>, void*)
operator delete(std::type_identity<T>, void*, std::size_t)
operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t)
```

We would like input from EWG on this matter.

## Design choice: Template argument vs `std::type_identity`

In an earlier draft, this paper was proposing the following (seemingly simpler) mechanism instead. Instead of
reusing `std::type_identity`, the compiler would search as per the following expression:

```cpp
operator new<T>(sizeof(T), args...)
```

The only difference here is that we're not passing `std::type_identity` as a first argument and we are passing
it as a template argument instead. Unfortunately, this has a number of problems. First, this doesn't allow ADL to kick
in, severely reducing the flexibility for defining the operator. Another problem is that existing code is allowed to
have defined a global `operator new` like so:

```cpp
template <class ...Args>
void* operator new(std::size_t size, Args ...args);
```

We believe that this is not a far fetched possibility and that we may break some code if we went down that route.
Even worse, an existing templated `operator new` could match even though it was never intended to be called. The
result would be that the first template argument is explicitly provided by the compiler, which could result in a
substitution failure (that is acceptable) or in a valid function call triggering an implicit conversion to the
now-explicitly-provided first template argument, which would change the meaning of valid programs.

Finally, without this tag parameter it is not possible to distinguish a template type aware allocator from any other
templated operator. This distinction is necessary for the semantics of new and delete in a number of contexts, especially
the concept of a "usual deallocation function".

## Is the current name lookup for `T::operator new` done this way on purpose?

Currently, the search that happens for a new-expression is worded such that if a `T::operator new` is found and
overload resolution fails, the program is ill-formed. As explained in this proposal, this is stricter than needed
and we propose relaxing that.

However, one side effect of this strictness is that the compiler will error if a user defines some variants of
`T::operator new` but forgets to define some other variants. [For example](https://godbolt.org/z/vEsc81h59):

```cpp
struct arg { };

struct Foo {
  static void* operator new(std::size_t, arg);
};

int main() {
  new Foo();
}
```

Today, this is a compiler error because we find `Foo::operator new` and then fail to perform overload resolution,
so we don't fall back to the global `::operator new`. I don't know whether this is by design or just an unintended
consequence of the wording, however this seems a bit contrived.

In all cases, if we wanted this to remain ill-formed, we could either count on compiler diagnostics to warn in that
case, or we could word the search process to say that if the overload resolution on `T::operator new` fails, the
program is ill-formed and the search stops. This doesn't seem useful to me, but it's on the table.

<!--
## Should a templated operator delete be allowed as a usual allocation function?

[dynamic.deallocation#3](https://timsong-cpp.github.io/cppwp/n4950/basic.stc.dynamic.deallocation#3) states that a template function
is never considered as a usual allocation function. This prevents general allocators from specifying a general type-aware deallocation
operator that can reflect the correct concrete type when invoking a deleting constructor. e.g.

```cpp
class Root {
public:
  template <class T> static void *operator new(std::size_t, std::type_identity<T>);
  template <class T> static void operator delete(void *, std::type_identity<T>);
};

class A : public Root { };

class B : public Root {
  virtual ~B();
};
class C : public B { };

int foo(A* a, B* b, B* c /* actually points to a C object */) {
  delete a; // We want Root::operator delete<A>(...) to be called

  delete b; // We want Root::operator delete<B> to be called, and that happens via
            // the deleting virtual destructor.
            // TODO

  delete c; // The allocator would call the deleting virtual destructor, and expect this to invoke
            // Root::operator delete<C>
            // TODO
}
```

Allowing a template delete operator to be considered a usual allocation function could result in previously ignored delete declarations being invoked. We could mitigate this risk by constraining the selection of template `usual` allocations to solely allow the typed allocation signatures - the existing selection rules for usual allocation functions already have strict parameter type restrictions on what is required for an allocation function to be usual so this is not wholly without precedence.
-->

# Suggested polls

1. Do we want to solve the problem of providing a type aware `operator new` as a free function?
2. Do we prefer `std::type_identity` after the size and alignment (status quo), or first in the argument list?
