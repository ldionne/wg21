---
title: "Type-aware allocation and deallocation functions"
document: P2719R1
date: 2024-10-16
audience: Evolution
author:
  - name: Louis Dionne
    email: <ldionne@apple.com>
  - name: Oliver Hunt
    email: <oliver@apple.com>
toc: false
toc-depth: 4
---

# Introduction

C++ currently provides two ways of customizing the creation of objects in new expressions. First, `operator new` can
be provided as a static member function of a class, like `void* T::operator new`. If such a declaration is provided, an
expression like `new T(...)` will use that allocation function. Otherwise, the global version of `operator new` can be
replaced by users in a type-agnostic way, by implementing `void* operator new(size_t)` and its variants. A similar
mechanism exists for _delete-expressions_.

This paper proposes an extension to _new-expressions_ and _delete-expressions_ to provide the concrete type being
[de]allocated to the allocation functions. This is achieved via the addition of an additional `std::type_identity<T>`
tag argument that allows the provision of the concrete type to `operator new` and `operator delete`. In addition to
providing valuable information to the allocator, this allows the creation of type-specific `operator new` and
`operator delete` for types that cannot have intrusive class-scoped operators specified.

<!-- I think the following should just be moved down to how things work section -->

When evaluating a new or delete expression, the compiler first finds the set of candidate declarations of the required
operator name. When operating on non class types only the global scope is searched. If operating on a class type, we
first search the class scope for the requested operator names, and only if no declarations of the correct name are
found do we then include the global scope in our search space.

Once the candidates are found, we perform overload resolution on the candidates over the language specified optional
implicit parameters, and if present any developer provided placement arguments. This proposal introduces a new optional
implicit parameter, that has higher priority than all existing implicit parameters, and as such changes overload
resolution ordering.

At a high level the operator resolution changes as follows

```cpp
// user writes:
new (args...) T(...)
```

Once determing the source scope and collecting the candidate declarations, the compiler attempts to perform overload
resolution over the set of candidates in the following order

<!-- I'm really not sure how to present candidate resolution, i feel it's important to
     explain new/delete don't behave as completely trivial function resolution but have
     a unique "find the best set of implicit parameters first" step -->

::: cmptable

### Before
```cpp
Candidate(size_t, align_val_t, args...)
Candidate(size_t, args...)
```

### After
```cpp
// compiler checks:
@[Candidate(type_identity<T>, size_t, align_val_t, args...)]{.add}@
@[Candidate(type_identity<T>, size_t, args...)]{.add}@
Candidate(size_t, align_val_t, args...)
Candidate(size_t, args...)
```

:::

Resolution ordering for _delete-expressions_ matches that of _new-expressions_, only with minor changes to incorporate
additional implicit _destroying_ and _size_ parameters.

:::

# Revision history

- R0: Initial version
- R1 (based on St-Louis feedback and implementation experience):
  - Simplified the lookup mechanism by removing the need to perform ADL
  - Allowed `std::type_identity` parameter in `operator new` defined at class scope for consistency
  - LOUIS: TODO: Added justification for taking `std::type_identity<T>` instead of `T*` as a first argument.
  - LOUIS: TODO: Added explanation of what happens w.r.t. ODR and mismatched new/delete operators
  - LOUIS: TODO: Mention interactions with `std::allocator` and that we can resolve that separately

<!-- OLIVER TODO: Make sure it renders nicely -->

# Motivation

Knowledge of the type being allocated in a _new-expression_ is necessary in order to achieve certain levels of flexibility
and security when defining a custom allocation function. Even when using in-class definitions, the only information
available to the implementation is the type declaring the operator, and subclasses remain opaque. This results in
developers using extensively copy-pasted macros to try construct the require allocation functions manually, or having to
completely circumvent the language provided new and delete expressions in order to track the allocated types.

Beyond exposing concrete allocation type to an allocator, a common problem in we see in the wild, are codebases overriding
the global (and untyped) `operator new` via the usual link-time mechanism and running into issues because they really only
intended for their custom `operator new` to be used within their own code, not by all the code in their process. We also
run into issues where multiple libraries attempt to replace the global `operator new` and end up with a complex ODR
violation bug. By providing the concrete type information to allocators at compile time it becomes possible for authors
to restrict their allocator definitions to just the types for which they are intended.

The changes proposed by this paper provide a mechanism for code bases to implement smarter and more secure allocators,
and to more easily implement what they _actually_ want, which is to override `operator new` for a family of types that
they control without overriding it for the whole process.

## A concrete use case

A few years ago, Apple published [a blog post](https://security.apple.com/blog/towards-the-next-generation-of-xnu-memory-safety)
explaining a technique used inside its kernel (XNU) to mitigate various exploits. At its core, the technique roughly
consists in allocating objects of each type in a different bucket. By collocating all objects of the same type into the
same region of memory, it becomes much harder for an attacker to exploit a type confusion vulnerability. Since its
introduction in the kernel, this technique alone has been by far the most effective at mitigating type confusion
vulnerabilities.

In a world where security is increasingly important, it may make sense for some code bases to adopt mitigation techniques
such as this one. However, these techniques require a large-scale and _almost_ system-wide customization of how allocation
is performed while retaining type information, which is not supported by C++ today. While not sufficient in itself to make
C++ safer, the change proposed in this paper is a necessary building block for technology such as the above which can
greatly improve the security of C++ applications.

# Current behavior recap

Today, the compiler performs [a lookup](https://timsong-cpp.github.io/cppwp/n4950/expr.new#12) in the allocated type's class
scope (for `T::operator new`), and then a lookup in the global scope (for `::operator new`) if the previous one failed. Once
the name lookup has been done and the compiler has decided whether it was looking for `T::operator new` or `::operator new`,
name lookup will not be done again even if the steps that follow were to fail.

The compiler then performs [overload resolution](https://timsong-cpp.github.io/cppwp/n4950/expr.new#19) on the name it found
in the previous step (let's call that name `NEW`) by assembling an argument list that depends on whether `T` has a new-extended
alignment or not. For the sake of simplicity, assume that `T` does not have a new-extended alignment. The compiler starts by
performing overload resolution as-if the following expression were used:

```cpp
NEW(sizeof(T), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the compiler performs overload resolution
again as-if the following expression were used:

```cpp
NEW(sizeof(T), std::align_val_t(alignof(T)), args...)
```

If that succeeds, the compiler selects the overload that won. If it does not, the program is ill-formed. For a type `T`
that has new-extended alignment, the order of the two overload resolutions performed above is simply reversed.

Delete-expressions behave similarly, with lookup being performed in the context of the dynamic type of the object, in
case it differs from its static type. The overload resolution process then works by preferring a destroying delete,
followed by an aligned delete (if the type has new-extended alignment), followed by the usual `operator delete` (with
or without a `size_t` parameter depending on whether the considered `operator delete` is a member function or not).

# Proposal

This proposal adds a new implicit tag argument of type `std::type_identity<T>` to `operator new` and `operator delete` that
is incorporated into the existing declaration preference logic with a higher priority than existing implicit parameters.
To avoid conficts with existing code, this parameter is placed as the first argument to the operator, preceding the size or
subject pointer. For such a declaration to be valid we require that the parameter be explicitly a specialization
of `std::type_identity`, and not a fully dependent type. This is analogous to the current specification behavior requiring
specific concrete types in the parameter list, even in dependent contexts, only with the caveat that for the purpose of this
proposal the type parameters applied to the `std::type_identity` tag necessarily may be dependent.

To simplify the text we will refer to an allocation operator in which the first parameter is a specialization of
`std::type_identity` as being a "type aware allocator", regardless of whether the specialized tag type is dependent or not.

To effectively support this new tag it is necessary to update the definition of a usual deallocation function
([basic.stc.dynamic.deallocation]) to include this new parameter, which requires the following:

* Allow the first parameter to be a specialization of type_identity, and update to position requirements of later
parameters to include that.
* Allow the function to have template parameters as long as the function is a type aware `operator delete` and the
only dependent parameter is a `std::type_identity` specialization in the first parameter position.

Once a set of candidate declarations has been found we perform the same prioritized overload resolution steps,
only with the addition of the type_identity tag, with a higher priority than the existing size and alignment
parameters. This gives us the following overload resolution ordering for operator new:

```cpp
1. NEW(type_identity<T>, size_t, align_val_t, args...)
2. NEW(type_identity<T>, size_t, args...)
3. NEW(size_t, align_val_t, args...)
4. NEW(size_t, args...)
```

If multiple candidates match a given set of parameters, then operator prioritisation and selection is performed
according to standard constraint precedence rules.

When a constructor throws an exception, a cleanup call is made to `operator delete`. The semantics of this cleanup
resolution remain essentially the same, the only difference being that the `operator delete` selected during overload
resolution must have the same type awareness as the preceding `operator new` or the program is considered ill formed.

Overload resolution for delete expressions is effectively the same, only with minor variations on the implicit
parameter types.

## Free function example

```cpp
struct SingleClass { };
struct UnrelatedClass { };
struct BaseClass { };
struct SubClass1 : BaseClass { };
struct SubClass2 : BaseClass { };
struct SubClass3 : BaseClass { };
void* operator new(std::type_identity<SingleClass>, std::size_t); // (1)
template <typename T> void* operator new(std::type_identity<T>, std::size_t); // (2)

template <std::derived_from<BaseClass> T>
void* operator new(std::type_identity<T>, std::size_t); // (3)
void* operator new(std::type_identity<SubClass2>, std::size_t); // (4)
void* operator new(std::type_identity<SubClass3>, std::size_t) = delete; // (5)

struct SubClass4 : BaseClass {
  void *operator new(size_t); // (6)
};

void f() {
  new SingleClass();     // calls (1)
  new UnrelatedClass();  // calls (2)
  new BaseClass();       // calls (3) with T=BaseClass
  new SubClass1();       // calls (3) with T=SubClass1
  new SubClass2();       // calls (4)
  new SubClass3();       // resolves (5) reports error due to deleted operator
  new SubClass4();       // calls (6) as the class scoped allocator wins
  new int();             // calls (2) with T=int
}
```

## In class example
```cpp
// In class operator
class SubClass1;
struct BaseClass {
  template <typename T>
  void* operator new(std::type_identity<T>, std::size_t); // (1)
  void* operator new(std::type_identity<SubClass1>, std::size_t); // (2)
};

struct SubClass1 : BaseClass { };
struct SubClass2 : BaseClass { };
struct SubClass3 : BaseClass {
  void *operator new(std::size_t); // (3)
};
struct SubClass4 : BaseClass {
  template <typename T>
  void *operator new(std::type_identity<T>, std::size_t); // (4)
};

void f() {
  new BaseClass;         // calls (1) with T=BaseClass
  new SubClass1();       // calls (2)
  new SubClass2();       // calls (1) with T=SubClass2
  new SubClass3();       // calls (3)
  new SubClass4();       // calls (4) with T=SubClass4
  ::new BaseClass();     // ingnores in class operators and uses appropriate global operator
}
```

# Design choices and notes

## Impact on the library

This proposal does not have any impact on the library, since this only tweaks the search process performed by the
compiler when it evaluates a new-expression and a delete-expression. In particular, we do not propose adding new
type-aware free function `operator new` variants in the standard library at this time, althought this could be
investigated in the future.

## Design choice: Template argument vs tag parameter

In an earlier draft, this paper was proposing the following (seemingly simpler) mechanism instead. Instead of
reusing `std::type_identity` as a tag parameter, the compiler would search as per the following expression:

```cpp
operator new<T>(sizeof(T), args...)
```

The only difference here is that we're not passing `std::type_identity` as a first argument and we are passing
it as a template argument instead. Unfortunately, this has a number of problems, the most significant of which
is that without a tag parameter it is not possible to distinguish a type aware allocation operator from existing
template operator declarations.

The first problem of note is we want to support type aware deallocation functions as usual deallocation functions.
Without an explicit type tag this distinction is not possible which leaves us unable to distinguish a type aware deallocation function from any other templated `operator delete`. Absent this distinction this feature would
create the risk of inappropriately calling `operator delete` implementations in existing code bases in scnerios
they have not previously been invoked.

In addition to this issue, there are also questions of how these semantics interact with existing templated
operators, as an example

```cpp
template <class ...Args>
void operator delete(void *, Args...);
size_t *sz_ptr = ...;
delete sz_ptr;
```

Because in this model allocation of a type aware operator must be explicit, we will explicitly instantiate
this as `operator delete<size_t>` as a type aware allocator, and in doing so this would also be validly
interpreted as a size aware deallocator. It is unclear which would be preferred - if either - but for existing
code this is the difference between the candidate being a valid usual deallocation function or not, so this
semantic change (althought theoretically not encounterable in this specific example) could introduce calls to
deletion operators where previously none occurred.

Finally, using a tag parameter allows a developer to more easliy specify allocation apis that are constrained
to specific concrete types. There are cases where a developer may not be able to specify in class allocation
operators, and being able to specify free operators with explict type constraints resolves this problem, e.g.

Without a tag parameter a developer in this position is required to write code similar to:

```cpp
struct S { ... };
template <typename T, typename = std::enable_if_t<std::is_same_v<T, S>>>
void *operator new(size_t);
```

Whereas with a tag they can simply specify the restriction explicity

```cpp
struct S { ... };
void *operator new(std::type_identity<S>, size_t);
```

While this last example is a minor nicety for developers, it is something we have considered.

Taken together we believe these issues warrant the use of an explicit tag parameter.

## Design choice: Use of `std::type_identity<T>` vs `T*`

In this proposal we have used `std::type_identity<T>` rather than using the outwardly simpler option of `T*`.

This perceived simplicity hides an array of subtle problems that are avoided through the use of `std::type_identity`.

### Problems with the value being passed
The first problem is the value that is passed as the tag parameter. Given an allocator signature of the form

```cpp
template <class T> void *operator new(T*, size_t) { ... }
template <class T> void operator delete(T*, void *) { ... }
```

A developer could reasonably be assumed to understand that the tag parameter to `operator new` would necessarily
be a null pointer, but for operator delete we can be assured that people will be confused about receiving two
pointer parameters, where the explicitly typed parameter is null. However we cannot pass the object pointer through
this parameter as this operator is called after the object has been destroyed, so providing the original pointer
would be an invitation to guaranteed undefined behaviour.

The confusion is further increased when considering a destroying operator delete

```cpp
struct Foo {
  template <class T> void operator delete(T*, Foo *, std::destroying_delete_t) { ... }
};

struct Bar : Foo { ... };

Bar *bar = ...;
delete bar;
// compiler invokes
Foo::operator delete<Bar>(nullptr, &bar, std::destroying_delete);
```

In this case the the developer's deletion operator is invoked on an object that has not been
destroyed, yet the concretely typed parameter is still a null pointer. Allowing the pointer
to be the object being deleted would lead to the same pointer being passed as two parameters
which may seem confusing, and introduces an arbitrary difference in the semantics of a parameter
that is used in the same way in the other operator variants.

### Problems with implicit capture of subtypes

A scenerio we have discussed is developers wishing to provide custom allocators for specific types,
when using a typed pointer as the tag, this would be written as

```cpp
struct S;
void *operator new(S*, size_t) { ... }
```

However this operator will also match any subtypes of `S`, which may be intended, but if it is not
intended the conversion from `Subtype*` to `S*` is entirely silent and may not be noticed. The robust
solution for this requires a reversion to the tag-free design above, i.e

```cpp
template <typename T, typename = std::enable_if_t<std::is_same_v<T, S>>>
void *operator new(T*, size_t);
```

### Performance considerations

There is a fundamental difference between `T*` and `std::type_identity<T>` in that `T*` is a type that
has an actual value and size, whereas `std::type_identity` is a zero sized record. This difference means
that the `T*` model results in an additional parameter being required in the generated code, whereas
the zero sized `type_identity` parameter does not exist in the majority of calling conventions.
In principle this difference should be minor for templated operators as they are typically inlined and
so the calling convention is not relevant, but for non-template definitions the implementation can be
out of line, and so the difference may matter.

## Design choice: Order of arguments

When writing this paper, we went back and forth of the order of arguments. This paper proposes:

```c++
operator new(std::type_identity<T>, std::size_t, placement-args...)
operator new(std::type_identity<T>, std::size_t, std::align_val_t, placement-args...)

operator delete(std::type_identity<T>, void*)
operator delete(std::type_identity<T>, void*, std::size_t)
operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t)
```

Another approach would be:

```c++
operator new(std::size_t, std::type_identity<T>, placement-args...)
operator new(std::size_t, std::align_val_t, std::type_identity<T>, placement-args...)

operator delete(void*, std::type_identity<T>)
operator delete(void*, std::size_t, std::type_identity<T>)
operator delete(void*, std::size_t, std::align_val_t, std::type_identity<T>)
```

The existing specification allows for the existence of template (including variadic template) declarations of
operator new and delete, and this functionality is used in existing code bases. This leads to problems compiling
real world code where overload resolution will allow selection of a non-SFINAE-safe declaration, and subsequently
breaks during compilation.

Placing the type tag preceding the size or pointer argument ensures that no existing operator definition can
match this new tag, and so we are guaranteed to be free from conflict.

An alternative to this would be to require passing an implicit `type_identity` parameter to require the relevant
parameter in the original function declaration always be a `type_identity<T>` specialization, similar to our
definition of type aware allocators in general. This would differ from the behavior with respect to other implicit
parameters that are permitted to bind to arbitrary template parameters.

## Design choice: Allowing template type aware `operator delete` as a usual deallocation function

Allowing type aware `operator delete` does require changes to the definition of usual deallocation functions,
but the changes are conceptually simple and the cost of not supporting this case is extremely high.

In the current specification we already place very tight requirements on what the type of an `operator delete`
definition must be in order to be considered a "usual deallocation function". The reason these definitions have
not allow template functions previously is because all of the implicit parameters are monomorphic types. In that
environment such a restriction makes sense.

However in this proposal we have introduced an implicit parameter that for which it is correct, and
expected, for the method to be templated. To that end we allowed a template `operator delete` to be
considered a usual deallocation function, as long as the only dependently typed parameter is the implicit
`type_identity` parameter. To our minds, these semantics match the "intent" of the restrictions already in
place for the other implicit parameters.

The cost of not allowing template type aware `operator delete` as a usual deallocation function is very high,
as it functionally prohibits the use of type aware allocation operators in any environment that depends of
being able to use usual deallocation functions. This is any environment where it is expected that constructors
may throw exceptions, and depend on object clean up, a condition that applies across from many custom "drop in"
allocator libraries all the way to general system allocators.

## Design choice: Destroying delete object type

One choice we have made is to not special case the treatment of destroying delete operators, so despite
providing the concrete type of an allocator, we still require destroying delete to receive the root type
as the object pointer, e.g.

```cpp
struct Foo {
  template <class T> void *operator new(type_identity<T>, size_t);
  template <class T> void operator delete(type_identity<T>, Foo *, std::destroying_delete_t);
};
```

We chose not to change the behavior here in order to simplify the semantic impact of this proposal, and
keep it as close as possible to being just a new implicit parameter for new and delete operators. In
principle we this proposal could be extended to allow:

```cpp
struct Foo {
  template <class T> void *operator new(type_identity<T>, size_t);
  template <class T> void operator delete(type_identity<T>, T *, std::destroying_delete_t);
};
```

But we note that the current specification also does not allow constructs such as the following:

```cpp
struct Bar;
struct Foo {
  void *operator new(size_t);
  void operator delete(Foo *, std::destroying_delete_t);
  void operator delete(Bar *, std::destroying_delete_t);
};
struct Bar : Foo { ... };
```

So in addition to the new implicit tag parameter and template argument, this would be introducing
functionality that is not permitted in the existing language while in priciple being a semantically
valid option. The authors of this proposal are not aware of the content of discussions when designing
destroying delete so we do not know if this restriction was the product of semantic arguments or
the limitations of the language at the time. An obvious reason for the existing restriction is that
the existing language has no way to verify a subtype relationship between types at the point the
delete operator is declared, and fundamentally that restriction does not change with this proposal.
A concretely typed destroying delete would have the same problem, and it is only by the delayed
instantiation enabled by use of templates that the subtyping restriction could be enforced in our
proposal.

As a result, while the type of the pointer provided to a type aware destroying delete could be
the concrete type at the point of invocation, the semantics of doing so don't meaningfully change
from those present in the existing destroying delete specification. As a result we believe that
extending destroying delete to support subtype dispatch is a more general issue that is outside of
the scope of this proposal.

## Design choice: ADL

The initial proposal allowed the specification of type aware allocators in namespaces that could
then be resolved via ADL. Upon further consideration this introduces a number of hazards to the
language that are complex to resolve robustly and as a result we have dropped support for
namespaced allocator declarations and removed the use of ADL from the proposal.

The first problem is declarations discovered from ADL over placement arguments. For operator new
these are not a problem, however the delete operator does not support placement arguments, so the
search scope can be significantly different between `new (args) Type` and the subsequent
`delete Object`.

Our hope was that by allowing namespaced operators we would simplify the work of constraining for
a library to constrain a custom allocator to just the types in that library, however there exist
myriad mechanisms by which a simple namespace only constraint is unintentionally expanded, the most
trivial of which is `new Namespace1::Type<Namespace2::Type>`. As a result a conscientious developer
will always need to appropriately constrain their type aware API, even if they were scoped.

As that work is functionally always required, the addition of ADL to the search phase does not
meaningfully improve the developer experience, and it introduces a hazard wherein a developer is not
aware that simply namespacing the declarations is insufficient - it will frequently appear to work
as expected - whereas there is already a strong understanding of the work involved in exposing and
overriding global allocation functions.

# Suggested polls

1. Do we agree on the use of `std::type_identity` as the tag type
2. Do we prefer `std::type_identity` before the size and alignment (status quo), or later in the argument list?
3. Do we agree that type aware allocators should be accepted as usual deallocation functions

